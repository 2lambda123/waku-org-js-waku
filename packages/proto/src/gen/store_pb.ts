// 13/WAKU2-STORE rfc: https://rfc.vac.dev/spec/13/
// Protocol identifier: /vac/waku/store/2.0.0-beta4

// @generated by protoc-gen-es v1.1.1 with parameter "target=ts"
// @generated from file store.proto (syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type {
  BinaryReadOptions,
  FieldList,
  JsonReadOptions,
  JsonValue,
  PartialMessage,
  PlainMessage,
} from "@bufbuild/protobuf";
import { Message, proto3, protoInt64 } from "@bufbuild/protobuf";
import { WakuMessage } from "./message_pb.js";

/**
 * @generated from message Index
 */
export class Index extends Message<Index> {
  /**
   * @generated from field: bytes digest = 1;
   */
  digest = new Uint8Array(0);

  /**
   * @generated from field: sint64 receiver_time = 2;
   */
  receiverTime = protoInt64.zero;

  /**
   * @generated from field: sint64 sender_time = 3;
   */
  senderTime = protoInt64.zero;

  /**
   * @generated from field: string pubsub_topic = 4;
   */
  pubsubTopic = "";

  constructor(data?: PartialMessage<Index>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "Index";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "digest", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    {
      no: 2,
      name: "receiver_time",
      kind: "scalar",
      T: 18 /* ScalarType.SINT64 */,
    },
    {
      no: 3,
      name: "sender_time",
      kind: "scalar",
      T: 18 /* ScalarType.SINT64 */,
    },
    {
      no: 4,
      name: "pubsub_topic",
      kind: "scalar",
      T: 9 /* ScalarType.STRING */,
    },
  ]);

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>
  ): Index {
    return new Index().fromBinary(bytes, options);
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>
  ): Index {
    return new Index().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>
  ): Index {
    return new Index().fromJsonString(jsonString, options);
  }

  static equals(
    a: Index | PlainMessage<Index> | undefined,
    b: Index | PlainMessage<Index> | undefined
  ): boolean {
    return proto3.util.equals(Index, a, b);
  }
}

/**
 * @generated from message PagingInfo
 */
export class PagingInfo extends Message<PagingInfo> {
  /**
   * @generated from field: optional uint64 page_size = 1;
   */
  pageSize?: bigint;

  /**
   * @generated from field: optional Index cursor = 2;
   */
  cursor?: Index;

  /**
   * @generated from field: optional PagingInfo.Direction direction = 3;
   */
  direction?: PagingInfo_Direction;

  constructor(data?: PartialMessage<PagingInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "PagingInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "page_size",
      kind: "scalar",
      T: 4 /* ScalarType.UINT64 */,
      opt: true,
    },
    { no: 2, name: "cursor", kind: "message", T: Index, opt: true },
    {
      no: 3,
      name: "direction",
      kind: "enum",
      T: proto3.getEnumType(PagingInfo_Direction),
      opt: true,
    },
  ]);

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>
  ): PagingInfo {
    return new PagingInfo().fromBinary(bytes, options);
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>
  ): PagingInfo {
    return new PagingInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>
  ): PagingInfo {
    return new PagingInfo().fromJsonString(jsonString, options);
  }

  static equals(
    a: PagingInfo | PlainMessage<PagingInfo> | undefined,
    b: PagingInfo | PlainMessage<PagingInfo> | undefined
  ): boolean {
    return proto3.util.equals(PagingInfo, a, b);
  }
}

/**
 * @generated from enum PagingInfo.Direction
 */
export enum PagingInfo_Direction {
  /**
   * @generated from enum value: BACKWARD = 0;
   */
  BACKWARD = 0,

  /**
   * @generated from enum value: FORWARD = 1;
   */
  FORWARD = 1,
}
// Retrieve enum metadata with: proto3.getEnumType(PagingInfo_Direction)
proto3.util.setEnumType(PagingInfo_Direction, "PagingInfo.Direction", [
  { no: 0, name: "BACKWARD" },
  { no: 1, name: "FORWARD" },
]);

/**
 * @generated from message ContentFilter
 */
export class ContentFilter extends Message<ContentFilter> {
  /**
   * @generated from field: string content_topic = 1;
   */
  contentTopic = "";

  constructor(data?: PartialMessage<ContentFilter>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ContentFilter";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "content_topic",
      kind: "scalar",
      T: 9 /* ScalarType.STRING */,
    },
  ]);

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>
  ): ContentFilter {
    return new ContentFilter().fromBinary(bytes, options);
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>
  ): ContentFilter {
    return new ContentFilter().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>
  ): ContentFilter {
    return new ContentFilter().fromJsonString(jsonString, options);
  }

  static equals(
    a: ContentFilter | PlainMessage<ContentFilter> | undefined,
    b: ContentFilter | PlainMessage<ContentFilter> | undefined
  ): boolean {
    return proto3.util.equals(ContentFilter, a, b);
  }
}

/**
 * @generated from message HistoryQuery
 */
export class HistoryQuery extends Message<HistoryQuery> {
  /**
   * The first field is reserved for future use
   *
   * @generated from field: optional string pubsub_topic = 2;
   */
  pubsubTopic?: string;

  /**
   * @generated from field: repeated ContentFilter content_filters = 3;
   */
  contentFilters: ContentFilter[] = [];

  /**
   * @generated from field: optional PagingInfo paging_info = 4;
   */
  pagingInfo?: PagingInfo;

  /**
   * @generated from field: optional sint64 start_time = 5;
   */
  startTime?: bigint;

  /**
   * @generated from field: optional sint64 end_time = 6;
   */
  endTime?: bigint;

  constructor(data?: PartialMessage<HistoryQuery>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "HistoryQuery";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    {
      no: 2,
      name: "pubsub_topic",
      kind: "scalar",
      T: 9 /* ScalarType.STRING */,
      opt: true,
    },
    {
      no: 3,
      name: "content_filters",
      kind: "message",
      T: ContentFilter,
      repeated: true,
    },
    { no: 4, name: "paging_info", kind: "message", T: PagingInfo, opt: true },
    {
      no: 5,
      name: "start_time",
      kind: "scalar",
      T: 18 /* ScalarType.SINT64 */,
      opt: true,
    },
    {
      no: 6,
      name: "end_time",
      kind: "scalar",
      T: 18 /* ScalarType.SINT64 */,
      opt: true,
    },
  ]);

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>
  ): HistoryQuery {
    return new HistoryQuery().fromBinary(bytes, options);
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>
  ): HistoryQuery {
    return new HistoryQuery().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>
  ): HistoryQuery {
    return new HistoryQuery().fromJsonString(jsonString, options);
  }

  static equals(
    a: HistoryQuery | PlainMessage<HistoryQuery> | undefined,
    b: HistoryQuery | PlainMessage<HistoryQuery> | undefined
  ): boolean {
    return proto3.util.equals(HistoryQuery, a, b);
  }
}

/**
 * @generated from message HistoryResponse
 */
export class HistoryResponse extends Message<HistoryResponse> {
  /**
   * The first field is reserved for future use
   *
   * @generated from field: repeated WakuMessage messages = 2;
   */
  messages: WakuMessage[] = [];

  /**
   * @generated from field: optional PagingInfo paging_info = 3;
   */
  pagingInfo?: PagingInfo;

  /**
   * @generated from field: HistoryResponse.HistoryError error = 4;
   */
  error = HistoryResponse_HistoryError.NONE;

  constructor(data?: PartialMessage<HistoryResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "HistoryResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    {
      no: 2,
      name: "messages",
      kind: "message",
      T: WakuMessage,
      repeated: true,
    },
    { no: 3, name: "paging_info", kind: "message", T: PagingInfo, opt: true },
    {
      no: 4,
      name: "error",
      kind: "enum",
      T: proto3.getEnumType(HistoryResponse_HistoryError),
    },
  ]);

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>
  ): HistoryResponse {
    return new HistoryResponse().fromBinary(bytes, options);
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>
  ): HistoryResponse {
    return new HistoryResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>
  ): HistoryResponse {
    return new HistoryResponse().fromJsonString(jsonString, options);
  }

  static equals(
    a: HistoryResponse | PlainMessage<HistoryResponse> | undefined,
    b: HistoryResponse | PlainMessage<HistoryResponse> | undefined
  ): boolean {
    return proto3.util.equals(HistoryResponse, a, b);
  }
}

/**
 * @generated from enum HistoryResponse.HistoryError
 */
export enum HistoryResponse_HistoryError {
  /**
   * @generated from enum value: NONE = 0;
   */
  NONE = 0,

  /**
   * @generated from enum value: INVALID_CURSOR = 1;
   */
  INVALID_CURSOR = 1,
}
// Retrieve enum metadata with: proto3.getEnumType(HistoryResponse_HistoryError)
proto3.util.setEnumType(
  HistoryResponse_HistoryError,
  "HistoryResponse.HistoryError",
  [
    { no: 0, name: "NONE" },
    { no: 1, name: "INVALID_CURSOR" },
  ]
);

/**
 * @generated from message HistoryRpc
 */
export class HistoryRpc extends Message<HistoryRpc> {
  /**
   * @generated from field: string request_id = 1;
   */
  requestId = "";

  /**
   * @generated from field: optional HistoryQuery query = 2;
   */
  query?: HistoryQuery;

  /**
   * @generated from field: optional HistoryResponse response = 3;
   */
  response?: HistoryResponse;

  constructor(data?: PartialMessage<HistoryRpc>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "HistoryRpc";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "request_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "query", kind: "message", T: HistoryQuery, opt: true },
    { no: 3, name: "response", kind: "message", T: HistoryResponse, opt: true },
  ]);

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>
  ): HistoryRpc {
    return new HistoryRpc().fromBinary(bytes, options);
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>
  ): HistoryRpc {
    return new HistoryRpc().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>
  ): HistoryRpc {
    return new HistoryRpc().fromJsonString(jsonString, options);
  }

  static equals(
    a: HistoryRpc | PlainMessage<HistoryRpc> | undefined,
    b: HistoryRpc | PlainMessage<HistoryRpc> | undefined
  ): boolean {
    return proto3.util.equals(HistoryRpc, a, b);
  }
}
