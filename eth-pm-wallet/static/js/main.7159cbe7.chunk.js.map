{"version":3,"sources":["../../../../../src/lib/waku_light_push/push_rpc.ts","../../../../../../src/lib/waku_message/symmetric/browser.ts","../../../../../../src/lib/waku_message/symmetric/node.ts","../../../../../src/lib/waku_relay/relay_heartbeat.ts","../../../../../src/lib/waku_store/history_rpc.ts","BroadcastPublicKey.tsx","messaging/Messages.tsx","messaging/Messaging.tsx","ConnectWallet.tsx","App.tsx","index.tsx","messaging/wire.ts","../../../src/index.ts","../../../../../src/lib/discovery/index.ts","../../../../src/lib/waku.ts","../../../../../src/lib/waku_message/index.ts","../../../../../../src/proto/waku/v2/message.ts","../../../../../src/lib/waku_relay/index.ts","../../../../../src/lib/waku_relay/constants.ts","crypto.ts","../../../../../src/lib/enr/index.ts","../../../../../../src/lib/enr/keypair/types.ts","../../../../src/lib/select_peer.ts","../../../../../src/lib/waku_light_push/index.ts","../../../../../../src/lib/waku_message/symmetric/index.ts","../../../../../src/lib/waku_store/index.ts","../../../../../src/lib/discovery/dns.ts","../../../../../src/lib/enr/v4.ts","../../../../../src/lib/enr/create.ts","../../../../../src/lib/enr/constants.ts","../../../../../../src/lib/enr/keypair/index.ts","../../../../../../src/lib/enr/keypair/secp256k1.ts","../../../../../src/lib/discovery/dns_over_https.ts","../../../../../src/lib/discovery/enrtree.ts","../../../../src/lib/utils.ts","../../../../../../src/proto/waku/v2/light_push.ts","../../../../../src/lib/waku_message/version_1.ts","../../../../../src/lib/waku_relay/get_relay_peers.ts","../../../../src/proto/index.ts","../../../../../../src/proto/waku/v2/store.ts","messaging/SendMessage.tsx","GetEncryptionPublicKey.tsx","../../../../../src/lib/discovery/hosted_json.ts","../../../../../src/lib/discovery/bootstrap.ts","waku.ts","../../../../../src/lib/enr/enr.ts","../../../../../../src/lib/enr/keypair/constants.ts"],"names":["a","p","BroadcastPublicKey","encryptionPublicKey","address","waku","providerRequest","Button","variant","color","onClick","console","log","createPublicKeyMessage","then","msg","encodePublicKeyWakuMessage","wakuMsg","lightPush","push","res","catch","e","error","disabled","publicKeyMessage","payload","encode","WakuMessage","fromBytes","PublicKeyContentTopic","Messages","messages","List","dense","generate","map","text","formatDisplayDate","timestamp","ListItem","ListItemText","primary","toLocaleString","month","day","hour","minute","hour12","useStyles","makeStyles","root","display","alignItems","flexDirection","margin","Messaging","recipients","classes","className","SendMessage","ConnectWallet","setAddress","setProvider","window","ethereum","request","method","accounts","_provider","ethers","providers","Web3Provider","theme","createMuiTheme","palette","main","orange","secondary","lightBlue","textAlign","minHeight","appBar","container","flex","wakuStatus","marginRight","spacing","title","flexGrow","peers","App","useState","setWaku","provider","encPublicKey","setEncPublicKey","Map","publicKeys","setPublicKeys","setMessages","relayPeers","lightPushPeers","peerStats","setPeerStats","useEffect","initWaku","_waku","observerPublicKeyMessage","handlePublicKeyMessage","bind","relay","addObserver","deleteObserver","observerPrivateMessage","handlePrivateMessage","PrivateMessageContentTopic","interval","setInterval","getPeers","size","length","clearInterval","addressDisplay","substr","ThemeProvider","AppBar","position","Toolbar","IconButton","edge","aria-label","undefined","style","teal","Typography","GetEncryptionPublicKey","ReactDOM","render","StrictMode","document","getElementById","Root","protobuf","Type","Field","PublicKeyMessage","message","create","this","finish","ethAddress","signature","bytes","decode","add","define","PrivateMessage","toAddress","exports","global","signEncryptionKey","hexToBuf","buildMsgParams","fromAddress","JSON","stringify","domain","chainId","name","version","bufToHex","ownerAddress","primaryType","types","EIP712Domain","type","PublishEncryptionPublicKey","msgParams","params","from","result","validatePublicKeyMessage","recovered","sigUtil","data","parse","sig","equalByteArrays","Promise","publicKey","aBuf","bBuf","envelope","buffer_1","Buffer","PagingInfo_Direction","pagingInfo_DirectionToJSON","toJSON","formControl","minWidth","selectEmpty","marginTop","recipient","setRecipient","setMessage","items","Array","keys","value","keyDownHandler","event","key","altKey","ctrlKey","shiftKey","get","sendMessage","flexWrap","id","labelId","onChange","target","label","onKeyDown","privateMessage","encObj","toString","encryptedPayload","recipientAddress","recipientPublicKey","callback","encodeEncryptedWakuMessage","isSuccess","code","n","nodes","Waku","bootstrap","default","resolve","reject","setTimeout","libp2p","connectionManager","on","myAddress","publicKeyMsg","prevPks","set","setter","payloadAsUtf8","decryptedPayload","Date","prevMsgs","copy","slice"],"mappings":"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","file":"static/js/main.7159cbe7.chunk.js","sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PushRPC = void 0;\nconst minimal_1 = require(\"protobufjs/minimal\");\nconst uuid_1 = require(\"uuid\");\nconst proto = __importStar(require(\"../../proto/waku/v2/light_push\"));\nclass PushRPC {\n    constructor(proto) {\n        this.proto = proto;\n    }\n    static createRequest(message, pubSubTopic) {\n        return new PushRPC({\n            requestId: uuid_1.v4(),\n            request: {\n                message: message.proto,\n                pubSubTopic: pubSubTopic,\n            },\n            response: undefined,\n        });\n    }\n    static decode(bytes) {\n        const res = proto.PushRPC.decode(minimal_1.Reader.create(bytes));\n        return new PushRPC(res);\n    }\n    encode() {\n        return proto.PushRPC.encode(this.proto).finish();\n    }\n    get query() {\n        return this.proto.request;\n    }\n    get response() {\n        return this.proto.response;\n    }\n}\nexports.PushRPC = PushRPC;\n//# sourceMappingURL=push_rpc.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.generateIv = exports.decrypt = exports.encrypt = void 0;\nconst index_1 = require(\"./index\");\nconst crypto = window.crypto || window.msCrypto;\nconst subtle = crypto.subtle || crypto.webkitSubtle;\nconst Algorithm = { name: 'AES-GCM', length: 128 };\nif (subtle === undefined) {\n    throw new Error('Failed to load Subtle CryptoAPI');\n}\nasync function encrypt(iv, key, clearText) {\n    return subtle\n        .importKey('raw', key, Algorithm, false, ['encrypt'])\n        .then((cryptoKey) => subtle.encrypt({ iv, ...Algorithm }, cryptoKey, clearText))\n        .then(Buffer.from);\n}\nexports.encrypt = encrypt;\nasync function decrypt(iv, key, cipherText) {\n    return subtle\n        .importKey('raw', key, Algorithm, false, ['decrypt'])\n        .then((cryptoKey) => subtle.decrypt({ iv, ...Algorithm }, cryptoKey, cipherText))\n        .then(Buffer.from);\n}\nexports.decrypt = decrypt;\nfunction generateIv() {\n    const iv = new Uint8Array(index_1.IvSize);\n    crypto.getRandomValues(iv);\n    return iv;\n}\nexports.generateIv = generateIv;\n//# sourceMappingURL=browser.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.generateIv = exports.decrypt = exports.encrypt = void 0;\nconst crypto_1 = require(\"crypto\");\nconst index_1 = require(\"./index\");\nconst Algorithm = 'aes-256-gcm';\nasync function encrypt(iv, key, clearText) {\n    const cipher = crypto_1.createCipheriv(Algorithm, key, iv);\n    const a = cipher.update(clearText);\n    const b = cipher.final();\n    const tag = cipher.getAuthTag();\n    return Buffer.concat([a, b, tag]);\n}\nexports.encrypt = encrypt;\nasync function decrypt(iv, key, data) {\n    const tagStart = data.length - index_1.TagSize;\n    const cipherText = data.slice(0, tagStart);\n    const tag = data.slice(tagStart);\n    const decipher = crypto_1.createDecipheriv(Algorithm, key, iv);\n    decipher.setAuthTag(tag);\n    const a = decipher.update(cipherText);\n    const b = decipher.final();\n    return Buffer.concat([a, b]);\n}\nexports.decrypt = decrypt;\nfunction generateIv() {\n    return crypto_1.randomBytes(index_1.IvSize);\n}\nexports.generateIv = generateIv;\n//# sourceMappingURL=node.js.map","\"use strict\";\n/**\n * @hidden\n * @module\n */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.RelayHeartbeat = void 0;\nconst heartbeat_1 = require(\"libp2p-gossipsub/src/heartbeat\");\nconst utils_1 = require(\"libp2p-gossipsub/src/utils\");\nconst constants = __importStar(require(\"./constants\"));\nconst get_relay_peers_1 = require(\"./get_relay_peers\");\nclass RelayHeartbeat extends heartbeat_1.Heartbeat {\n    /**\n     * @param {Object} gossipsub\n     * @constructor\n     */\n    constructor(gossipsub) {\n        super(gossipsub);\n    }\n    start() {\n        if (this._heartbeatTimer) {\n            return;\n        }\n        const heartbeat = this._heartbeat.bind(this);\n        const timeout = setTimeout(() => {\n            heartbeat();\n            this._heartbeatTimer?.runPeriodically(heartbeat, constants.RelayHeartbeatInterval);\n        }, constants.RelayHeartbeatInitialDelay);\n        this._heartbeatTimer = {\n            _intervalId: undefined,\n            runPeriodically: (fn, period) => {\n                // this._heartbeatTimer cannot be null, it is being assigned.\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                this._heartbeatTimer._intervalId = setInterval(fn, period);\n            },\n            cancel: () => {\n                clearTimeout(timeout);\n                clearInterval(this._heartbeatTimer?._intervalId);\n            },\n        };\n    }\n    /**\n     * Unmounts the gossipsub protocol and shuts down every connection\n     * @override\n     * @returns {void}\n     */\n    stop() {\n        if (!this._heartbeatTimer) {\n            return;\n        }\n        this._heartbeatTimer.cancel();\n        this._heartbeatTimer = null;\n    }\n    /**\n     * Maintains the mesh and fanout maps in gossipsub.\n     *\n     * @returns {void}\n     */\n    _heartbeat() {\n        const { D, Dlo, Dhi, Dscore, Dout } = this.gossipsub._options;\n        this.gossipsub.heartbeatTicks++;\n        // cache scores through the heartbeat\n        const scores = new Map();\n        const getScore = (id) => {\n            let s = scores.get(id);\n            if (s === undefined) {\n                s = this.gossipsub.score.score(id);\n                scores.set(id, s);\n            }\n            return s;\n        };\n        // peer id => topic[]\n        const toGraft = new Map();\n        // peer id => topic[]\n        const toPrune = new Map();\n        // peer id => don't px\n        const noPX = new Map();\n        // clean up expired backoffs\n        this.gossipsub._clearBackoff();\n        // clean up peerhave/iasked counters\n        this.gossipsub.peerhave.clear();\n        this.gossipsub.iasked.clear();\n        // apply IWANT request penalties\n        this.gossipsub._applyIwantPenalties();\n        // ensure direct peers are connected\n        this.gossipsub._directConnect();\n        // maintain the mesh for topics we have joined\n        this.gossipsub.mesh.forEach((peers, topic) => {\n            // prune/graft helper functions (defined per topic)\n            const prunePeer = (id) => {\n                this.gossipsub.log('HEARTBEAT: Remove mesh link to %s in %s', id, topic);\n                // update peer score\n                this.gossipsub.score.prune(id, topic);\n                // add prune backoff record\n                this.gossipsub._addBackoff(id, topic);\n                // remove peer from mesh\n                peers.delete(id);\n                // add to toPrune\n                const topics = toPrune.get(id);\n                if (!topics) {\n                    toPrune.set(id, [topic]);\n                }\n                else {\n                    topics.push(topic);\n                }\n            };\n            const graftPeer = (id) => {\n                this.gossipsub.log('HEARTBEAT: Add mesh link to %s in %s', id, topic);\n                // update peer score\n                this.gossipsub.score.graft(id, topic);\n                // add peer to mesh\n                peers.add(id);\n                // add to toGraft\n                const topics = toGraft.get(id);\n                if (!topics) {\n                    toGraft.set(id, [topic]);\n                }\n                else {\n                    topics.push(topic);\n                }\n            };\n            // drop all peers with negative score, without PX\n            peers.forEach((id) => {\n                const score = getScore(id);\n                if (score < 0) {\n                    this.gossipsub.log('HEARTBEAT: Prune peer %s with negative score: score=%d, topic=%s', id, score, topic);\n                    prunePeer(id);\n                    noPX.set(id, true);\n                }\n            });\n            // do we have enough peers?\n            if (peers.size < Dlo) {\n                const backoff = this.gossipsub.backoff.get(topic);\n                const ineed = D - peers.size;\n                const peersSet = get_relay_peers_1.getRelayPeers(this.gossipsub, topic, ineed, (id) => {\n                    // filter out mesh peers, direct peers, peers we are backing off, peers with negative score\n                    return (!peers.has(id) &&\n                        !this.gossipsub.direct.has(id) &&\n                        (!backoff || !backoff.has(id)) &&\n                        getScore(id) >= 0);\n                });\n                peersSet.forEach(graftPeer);\n            }\n            // do we have to many peers?\n            if (peers.size > Dhi) {\n                let peersArray = Array.from(peers);\n                // sort by score\n                peersArray.sort((a, b) => getScore(b) - getScore(a));\n                // We keep the first D_score peers by score and the remaining up to D randomly\n                // under the constraint that we keep D_out peers in the mesh (if we have that many)\n                peersArray = peersArray\n                    .slice(0, Dscore)\n                    .concat(utils_1.shuffle(peersArray.slice(Dscore)));\n                // count the outbound peers we are keeping\n                let outbound = 0;\n                peersArray.slice(0, D).forEach((p) => {\n                    if (this.gossipsub.outbound.get(p)) {\n                        outbound++;\n                    }\n                });\n                // if it's less than D_out, bubble up some outbound peers from the random selection\n                if (outbound < Dout) {\n                    const rotate = (i) => {\n                        // rotate the peersArray to the right and put the ith peer in the front\n                        const p = peersArray[i];\n                        for (let j = i; j > 0; j--) {\n                            peersArray[j] = peersArray[j - 1];\n                        }\n                        peersArray[0] = p;\n                    };\n                    // first bubble up all outbound peers already in the selection to the front\n                    if (outbound > 0) {\n                        let ihave = outbound;\n                        for (let i = 1; i < D && ihave > 0; i++) {\n                            if (this.gossipsub.outbound.get(peersArray[i])) {\n                                rotate(i);\n                                ihave--;\n                            }\n                        }\n                    }\n                    // now bubble up enough outbound peers outside the selection to the front\n                    let ineed = D - outbound;\n                    for (let i = D; i < peersArray.length && ineed > 0; i++) {\n                        if (this.gossipsub.outbound.get(peersArray[i])) {\n                            rotate(i);\n                            ineed--;\n                        }\n                    }\n                }\n                // prune the excess peers\n                peersArray.slice(D).forEach(prunePeer);\n            }\n            // do we have enough outbound peers?\n            if (peers.size >= Dlo) {\n                // count the outbound peers we have\n                let outbound = 0;\n                peers.forEach((p) => {\n                    if (this.gossipsub.outbound.get(p)) {\n                        outbound++;\n                    }\n                });\n                // if it's less than D_out, select some peers with outbound connections and graft them\n                if (outbound < Dout) {\n                    const ineed = Dout - outbound;\n                    const backoff = this.gossipsub.backoff.get(topic);\n                    get_relay_peers_1.getRelayPeers(this.gossipsub, topic, ineed, (id) => {\n                        // filter our current mesh peers, direct peers, peers we are backing off, peers with negative score\n                        return (!peers.has(id) &&\n                            !this.gossipsub.direct.has(id) &&\n                            (!backoff || !backoff.has(id)) &&\n                            getScore(id) >= 0);\n                    }).forEach(graftPeer);\n                }\n            }\n            // should we try to improve the mesh with opportunistic grafting?\n            if (this.gossipsub.heartbeatTicks %\n                constants.RelayOpportunisticGraftTicks ===\n                0 &&\n                peers.size > 1) {\n                // Opportunistic grafting works as follows: we check the median score of peers in the\n                // mesh; if this score is below the opportunisticGraftThreshold, we select a few peers at\n                // random with score over the median.\n                // The intention is to (slowly) improve an under performing mesh by introducing good\n                // scoring peers that may have been gossiping at us. This allows us to get out of sticky\n                // situations where we are stuck with poor peers and also recover from churn of good peers.\n                // now compute the median peer score in the mesh\n                const peersList = Array.from(peers).sort((a, b) => getScore(a) - getScore(b));\n                const medianIndex = Math.floor(peers.size / 2);\n                const medianScore = getScore(peersList[medianIndex]);\n                // if the median score is below the threshold, select a better peer (if any) and GRAFT\n                if (medianScore <\n                    this.gossipsub._options.scoreThresholds.opportunisticGraftThreshold) {\n                    const backoff = this.gossipsub.backoff.get(topic);\n                    const peersToGraft = get_relay_peers_1.getRelayPeers(this.gossipsub, topic, constants.RelayOpportunisticGraftPeers, (id) => {\n                        // filter out current mesh peers, direct peers, peers we are backing off, peers below or at threshold\n                        return (peers.has(id) &&\n                            !this.gossipsub.direct.has(id) &&\n                            (!backoff || !backoff.has(id)) &&\n                            getScore(id) > medianScore);\n                    });\n                    peersToGraft.forEach((id) => {\n                        this.gossipsub.log('HEARTBEAT: Opportunistically graft peer %s on topic %s', id, topic);\n                        graftPeer(id);\n                    });\n                }\n            }\n            // 2nd arg are mesh peers excluded from gossip. We have already pushed\n            // messages to them, so its redundant to gossip IHAVEs.\n            this.gossipsub._emitGossip(topic, peers);\n        });\n        // expire fanout for topics we haven't published to in a while\n        const now = this.gossipsub._now();\n        this.gossipsub.lastpub.forEach((lastpub, topic) => {\n            if (lastpub + constants.RelayFanoutTTL < now) {\n                this.gossipsub.fanout.delete(topic);\n                this.gossipsub.lastpub.delete(topic);\n            }\n        });\n        // maintain our fanout for topics we are publishing but we have not joined\n        this.gossipsub.fanout.forEach((fanoutPeers, topic) => {\n            // checks whether our peers are still in the topic and have a score above the publish threshold\n            const topicPeers = this.gossipsub.topics.get(topic);\n            fanoutPeers.forEach((id) => {\n                if (!topicPeers?.has(id) ||\n                    getScore(id) <\n                        this.gossipsub._options.scoreThresholds.publishThreshold) {\n                    fanoutPeers.delete(id);\n                }\n            });\n            // do we need more peers?\n            if (fanoutPeers.size < D) {\n                const ineed = D - fanoutPeers.size;\n                const peersSet = get_relay_peers_1.getRelayPeers(this.gossipsub, topic, ineed, (id) => {\n                    // filter out existing fanout peers, direct peers, and peers with score above the publish threshold\n                    return (!fanoutPeers.has(id) &&\n                        !this.gossipsub.direct.has(id) &&\n                        getScore(id) >=\n                            this.gossipsub._options.scoreThresholds.publishThreshold);\n                });\n                peersSet.forEach((id) => {\n                    fanoutPeers.add(id);\n                });\n            }\n            // 2nd arg are fanout peers excluded from gossip.\n            // We have already pushed messages to them, so its redundant to gossip IHAVEs\n            this.gossipsub._emitGossip(topic, fanoutPeers);\n        });\n        // send coalesced GRAFT/PRUNE messages (will piggyback gossip)\n        this.gossipsub._sendGraftPrune(toGraft, toPrune, noPX);\n        // flush pending gossip that wasn't piggybacked above\n        this.gossipsub._flush();\n        // advance the message history window\n        this.gossipsub.messageCache.shift();\n        this.gossipsub.emit('gossipsub:heartbeat');\n    }\n}\nexports.RelayHeartbeat = RelayHeartbeat;\n//# sourceMappingURL=relay_heartbeat.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.HistoryRPC = exports.PageDirection = void 0;\nconst minimal_1 = require(\"protobufjs/minimal\");\nconst uuid_1 = require(\"uuid\");\nconst proto = __importStar(require(\"../../proto/waku/v2/store\"));\nvar PageDirection;\n(function (PageDirection) {\n    PageDirection[\"BACKWARD\"] = \"backward\";\n    PageDirection[\"FORWARD\"] = \"forward\";\n})(PageDirection = exports.PageDirection || (exports.PageDirection = {}));\nclass HistoryRPC {\n    constructor(proto) {\n        this.proto = proto;\n    }\n    /**\n     * Create History Query.\n     */\n    static createQuery(params) {\n        const direction = directionToProto(params.pageDirection);\n        const pagingInfo = {\n            pageSize: params.pageSize,\n            cursor: params.cursor,\n            direction,\n        };\n        const contentFilters = params.contentTopics.map((contentTopic) => {\n            return { contentTopic };\n        });\n        return new HistoryRPC({\n            requestId: uuid_1.v4(),\n            query: {\n                pubSubTopic: params.pubSubTopic,\n                contentFilters,\n                pagingInfo,\n                startTime: params.startTime,\n                endTime: params.endTime,\n            },\n            response: undefined,\n        });\n    }\n    static decode(bytes) {\n        const res = proto.HistoryRPC.decode(minimal_1.Reader.create(bytes));\n        return new HistoryRPC(res);\n    }\n    encode() {\n        return proto.HistoryRPC.encode(this.proto).finish();\n    }\n    get query() {\n        return this.proto.query;\n    }\n    get response() {\n        return this.proto.response;\n    }\n}\nexports.HistoryRPC = HistoryRPC;\nfunction directionToProto(pageDirection) {\n    switch (pageDirection) {\n        case PageDirection.BACKWARD:\n            return proto.PagingInfo_Direction.DIRECTION_BACKWARD_UNSPECIFIED;\n        case PageDirection.FORWARD:\n            return proto.PagingInfo_Direction.DIRECTION_FORWARD;\n        default:\n            return proto.PagingInfo_Direction.DIRECTION_BACKWARD_UNSPECIFIED;\n    }\n}\n//# sourceMappingURL=history_rpc.js.map","import { Button } from '@material-ui/core';\nimport React from 'react';\nimport { createPublicKeyMessage } from './crypto';\nimport { PublicKeyMessage } from './messaging/wire';\nimport { WakuMessage, Waku } from 'js-waku';\nimport { PublicKeyContentTopic } from './waku';\n\ninterface Props {\n  encryptionPublicKey: Uint8Array | undefined;\n  waku: Waku | undefined;\n  address: string | undefined;\n  providerRequest:\n    | ((request: { method: string; params?: Array<any> }) => Promise<any>)\n    | undefined;\n}\n\nexport default function BroadcastPublicKey({\n  encryptionPublicKey,\n  address,\n  waku,\n  providerRequest,\n}: Props) {\n  const broadcastPublicKey = () => {\n    if (!encryptionPublicKey) return;\n    if (!address) return;\n    if (!waku) return;\n    if (!providerRequest) return;\n\n    console.log('Creating Public Key Message');\n    createPublicKeyMessage(address, encryptionPublicKey, providerRequest)\n      .then((msg) => {\n        console.log('Public Key Message created');\n        encodePublicKeyWakuMessage(msg)\n          .then((wakuMsg) => {\n            console.log('Public Key Message encoded');\n            waku.lightPush\n              .push(wakuMsg)\n              .then((res) => console.log('Public Key Message pushed', res))\n              .catch((e) => {\n                console.error('Failed to send Public Key Message', e);\n              });\n          })\n          .catch(() => {\n            console.log('Failed to encode Public Key Message in Waku Message');\n          });\n      })\n      .catch((e) => {\n        console.error('Failed to create public key message', e);\n      });\n  };\n\n  return (\n    <Button\n      variant=\"contained\"\n      color=\"primary\"\n      onClick={broadcastPublicKey}\n      disabled={!encryptionPublicKey || !waku || !address || !providerRequest}\n    >\n      Broadcast Encryption Public Key\n    </Button>\n  );\n}\n\nasync function encodePublicKeyWakuMessage(\n  publicKeyMessage: PublicKeyMessage\n): Promise<WakuMessage> {\n  const payload = publicKeyMessage.encode();\n  return await WakuMessage.fromBytes(payload, PublicKeyContentTopic);\n}\n","import React from 'react';\nimport { List, ListItem, ListItemText } from '@material-ui/core';\n\n/**\n * Clear text message\n */\nexport interface Message {\n  text: string;\n  timestamp: Date;\n}\n\nexport interface Props {\n  messages: Message[];\n}\n\nexport default function Messages({ messages }: Props) {\n  return <List dense={true}>{generate(messages)}</List>;\n}\n\nfunction generate(messages: Message[]) {\n  return messages.map((msg) => {\n    const text = `<${formatDisplayDate(msg.timestamp)}> ${msg.text}`;\n\n    return (\n      <ListItem>\n        <ListItemText key={formatDisplayDate(msg.timestamp)} primary={text} />\n      </ListItem>\n    );\n  });\n}\n\nfunction formatDisplayDate(timestamp: Date): string {\n  return timestamp.toLocaleString([], {\n    month: 'short',\n    day: 'numeric',\n    hour: 'numeric',\n    minute: '2-digit',\n    hour12: false,\n  });\n}\n","import Messages, { Message } from './Messages';\nimport { Waku } from 'js-waku';\nimport SendMessage from './SendMessage';\nimport { makeStyles } from '@material-ui/core';\n\nconst useStyles = makeStyles({\n  root: {\n    display: 'flex',\n    alignItems: 'left',\n    flexDirection: 'column',\n    margin: '5px',\n  },\n});\n\ninterface Props {\n  waku: Waku | undefined;\n  recipients: Map<string, Uint8Array>;\n  messages: Message[];\n}\n\nexport default function Messaging({ waku, recipients, messages }: Props) {\n  const classes = useStyles();\n\n  return (\n    <div className={classes.root}>\n      <SendMessage recipients={recipients} waku={waku} />\n      <Messages messages={messages} />\n    </div>\n  );\n}\n","import { Button } from '@material-ui/core';\nimport React from 'react';\nimport { ethers } from 'ethers';\nimport { Web3Provider } from '@ethersproject/providers/src.ts/web3-provider';\n\ndeclare let window: any;\n\ninterface Props {\n  setAddress: (address: string) => void;\n  setProvider: (provider: Web3Provider) => void;\n}\n\nexport default function ConnectWallet({ setAddress, setProvider }: Props) {\n  const connectWallet = () => {\n    try {\n      window.ethereum\n        .request({ method: 'eth_requestAccounts' })\n        .then((accounts: string[]) => {\n          const _provider = new ethers.providers.Web3Provider(window.ethereum);\n          setAddress(accounts[0]);\n          setProvider(_provider);\n        });\n    } catch (e) {\n      console.error('No web3 provider available');\n    }\n  };\n\n  return (\n    <Button variant=\"contained\" color=\"primary\" onClick={connectWallet}>\n      Connect Wallet\n    </Button>\n  );\n}\n","import '@ethersproject/shims';\n\nimport React, { useEffect, useState } from 'react';\nimport './App.css';\nimport { Waku } from 'js-waku';\nimport { Message } from './messaging/Messages';\nimport 'fontsource-roboto';\nimport { AppBar, IconButton, Toolbar, Typography } from '@material-ui/core';\nimport {\n  createMuiTheme,\n  ThemeProvider,\n  makeStyles,\n} from '@material-ui/core/styles';\nimport { lightBlue, orange, teal } from '@material-ui/core/colors';\nimport WifiIcon from '@material-ui/icons/Wifi';\nimport BroadcastPublicKey from './BroadcastPublicKey';\nimport Messaging from './messaging/Messaging';\nimport {\n  PrivateMessageContentTopic,\n  handlePrivateMessage,\n  handlePublicKeyMessage,\n  initWaku,\n  PublicKeyContentTopic,\n} from './waku';\nimport { Web3Provider } from '@ethersproject/providers/src.ts/web3-provider';\nimport GetEncryptionPublicKey from './GetEncryptionPublicKey';\nimport ConnectWallet from './ConnectWallet';\n\nconst theme = createMuiTheme({\n  palette: {\n    primary: {\n      main: orange[500],\n    },\n    secondary: {\n      main: lightBlue[600],\n    },\n  },\n});\n\nconst useStyles = makeStyles({\n  root: {\n    textAlign: 'center',\n    display: 'flex',\n    flexDirection: 'column',\n    minHeight: '100vh',\n  },\n  appBar: {\n    // height: '200p',\n  },\n  container: {\n    display: 'flex',\n    flex: 1,\n  },\n  main: {\n    flex: 1,\n    margin: '10px',\n  },\n  wakuStatus: {\n    marginRight: theme.spacing(2),\n  },\n  title: {\n    flexGrow: 1,\n  },\n  peers: {},\n});\n\nfunction App() {\n  const [waku, setWaku] = useState<Waku>();\n  const [provider, setProvider] = useState<Web3Provider>();\n  const [encPublicKey, setEncPublicKey] = useState<Uint8Array>();\n  const [publicKeys, setPublicKeys] = useState<Map<string, Uint8Array>>(\n    new Map()\n  );\n  const [messages, setMessages] = useState<Message[]>([]);\n  const [address, setAddress] = useState<string>();\n  const [peerStats, setPeerStats] = useState<{\n    relayPeers: number;\n    lightPushPeers: number;\n  }>({\n    relayPeers: 0,\n    lightPushPeers: 0,\n  });\n\n  const classes = useStyles();\n\n  // Waku initialization\n  useEffect(() => {\n    if (waku) return;\n    initWaku()\n      .then((_waku) => {\n        console.log('waku: ready');\n        setWaku(_waku);\n      })\n      .catch((e) => {\n        console.error('Failed to initiate Waku', e);\n      });\n  }, [waku]);\n\n  useEffect(() => {\n    if (!waku) return;\n\n    const observerPublicKeyMessage = handlePublicKeyMessage.bind(\n      {},\n      address,\n      setPublicKeys\n    );\n\n    waku.relay.addObserver(observerPublicKeyMessage, [PublicKeyContentTopic]);\n\n    return function cleanUp() {\n      if (!waku) return;\n      waku.relay.deleteObserver(observerPublicKeyMessage, [\n        PublicKeyContentTopic,\n      ]);\n    };\n  }, [waku, address]);\n\n  useEffect(() => {\n    if (!waku) return;\n    if (!address) return;\n    if (!provider?.provider?.request) return;\n\n    const observerPrivateMessage = handlePrivateMessage.bind(\n      {},\n      setMessages,\n      address,\n      provider.provider.request\n    );\n\n    waku.relay.addObserver(observerPrivateMessage, [\n      PrivateMessageContentTopic,\n    ]);\n\n    return function cleanUp() {\n      if (!waku) return;\n      if (!observerPrivateMessage) return;\n      waku.relay.deleteObserver(observerPrivateMessage, [\n        PrivateMessageContentTopic,\n      ]);\n    };\n  }, [waku, address, provider?.provider?.request]);\n\n  useEffect(() => {\n    if (!waku) return;\n\n    const interval = setInterval(() => {\n      setPeerStats({\n        relayPeers: waku.relay.getPeers().size,\n        lightPushPeers: waku.lightPush.peers.length,\n      });\n    }, 1000);\n    return () => clearInterval(interval);\n  }, [waku]);\n\n  let addressDisplay = '';\n  if (address) {\n    addressDisplay =\n      address.substr(0, 6) + '...' + address.substr(address.length - 4, 4);\n  }\n\n  return (\n    <ThemeProvider theme={theme}>\n      <div className={classes.root}>\n        <AppBar className={classes.appBar} position=\"static\">\n          <Toolbar>\n            <IconButton\n              edge=\"start\"\n              className={classes.wakuStatus}\n              aria-label=\"waku-status\"\n            >\n              <WifiIcon\n                color={waku ? undefined : 'disabled'}\n                style={waku ? { color: teal[500] } : {}}\n              />\n            </IconButton>\n            <Typography className={classes.peers} aria-label=\"connected-peers\">\n              Peers: {peerStats.relayPeers} relay, {peerStats.lightPushPeers}{' '}\n              light push\n            </Typography>\n            <Typography variant=\"h6\" className={classes.title}>\n              Ethereum Private Message with Wallet Encryption\n            </Typography>\n            <Typography>{addressDisplay}</Typography>\n          </Toolbar>\n        </AppBar>\n\n        <div className={classes.container}>\n          <main className={classes.main}>\n            <fieldset>\n              <legend>Wallet</legend>\n              <ConnectWallet\n                setProvider={setProvider}\n                setAddress={setAddress}\n              />\n            </fieldset>\n            <fieldset>\n              <legend>Encryption Keys</legend>\n              <GetEncryptionPublicKey\n                setEncPublicKey={setEncPublicKey}\n                providerRequest={provider?.provider?.request}\n                address={address}\n              />\n              <BroadcastPublicKey\n                address={address}\n                encryptionPublicKey={encPublicKey}\n                waku={waku}\n                providerRequest={provider?.provider?.request}\n              />\n            </fieldset>\n            <fieldset>\n              <legend>Messaging</legend>\n              <Messaging\n                recipients={publicKeys}\n                waku={waku}\n                messages={messages}\n              />\n            </fieldset>\n          </main>\n        </div>\n      </div>\n    </ThemeProvider>\n  );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n","import * as protobuf from 'protobufjs/light';\n\nexport interface PublicKeyMessagePayload {\n  encryptionPublicKey: Uint8Array;\n  ethAddress: Uint8Array;\n  signature: Uint8Array;\n}\n\nconst Root = protobuf.Root,\n  Type = protobuf.Type,\n  Field = protobuf.Field;\n\n/**\n * Message used to communicate the encryption public key linked to a given Ethereum account\n */\nexport class PublicKeyMessage {\n  private static Type = new Type('PublicKeyMessage')\n    .add(new Field('encryptionPublicKey', 1, 'bytes'))\n    .add(new Field('ethAddress', 2, 'bytes'))\n    .add(new Field('signature', 3, 'bytes'));\n  private static Root = new Root()\n    .define('messages')\n    .add(PublicKeyMessage.Type);\n\n  constructor(public payload: PublicKeyMessagePayload) {}\n\n  public encode(): Uint8Array {\n    const message = PublicKeyMessage.Type.create(this.payload);\n    return PublicKeyMessage.Type.encode(message).finish();\n  }\n\n  public static decode(\n    bytes: Uint8Array | Buffer\n  ): PublicKeyMessage | undefined {\n    const payload = PublicKeyMessage.Type.decode(\n      bytes\n    ) as unknown as PublicKeyMessagePayload;\n    if (\n      !payload.signature ||\n      !payload.encryptionPublicKey ||\n      !payload.ethAddress\n    ) {\n      console.log('Field missing on decoded Public Key Message', payload);\n      return;\n    }\n    return new PublicKeyMessage(payload);\n  }\n\n  get encryptionPublicKey(): Uint8Array {\n    return this.payload.encryptionPublicKey;\n  }\n\n  get ethAddress(): Uint8Array {\n    return this.payload.ethAddress;\n  }\n\n  get signature(): Uint8Array {\n    return this.payload.signature;\n  }\n}\n\nexport interface PrivateMessagePayload {\n  toAddress: Uint8Array;\n  message: string;\n}\n\n/**\n * Encrypted Message used for private communication over the Waku network.\n */\nexport class PrivateMessage {\n  private static Type = new Type('PrivateMessage')\n    .add(new Field('toAddress', 1, 'bytes'))\n    .add(new Field('message', 2, 'string'));\n  private static Root = new Root().define('messages').add(PrivateMessage.Type);\n\n  constructor(public payload: PrivateMessagePayload) {}\n\n  public encode(): Uint8Array {\n    const message = PrivateMessage.Type.create(this.payload);\n    return PrivateMessage.Type.encode(message).finish();\n  }\n\n  public static decode(bytes: Uint8Array | Buffer): PrivateMessage | undefined {\n    const payload = PrivateMessage.Type.decode(\n      bytes\n    ) as unknown as PrivateMessagePayload;\n    if (!payload.toAddress || !payload.message) {\n      console.log('Field missing on decoded PrivateMessage', payload);\n      return;\n    }\n    return new PrivateMessage(payload);\n  }\n\n  get toAddress(): Uint8Array {\n    return this.payload.toAddress;\n  }\n\n  get message(): string {\n    return this.payload.message;\n  }\n}\n","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.proto = exports.StoreCodec = exports.WakuStore = exports.PageDirection = exports.waku_store = exports.RelayCodecs = exports.WakuRelay = exports.waku_relay = exports.PushResponse = exports.LightPushCodec = exports.WakuLightPush = exports.waku_light_push = exports.getPublicKey = exports.generateSymmetricKey = exports.generatePrivateKey = exports.WakuMessage = exports.waku_message = exports.DefaultPubSubTopic = exports.Waku = exports.waku = exports.utils = exports.enr = exports.discovery = exports.getNodesFromHostedJson = void 0;\nvar discovery_1 = require(\"./lib/discovery\");\nObject.defineProperty(exports, \"getNodesFromHostedJson\", { enumerable: true, get: function () { return discovery_1.getNodesFromHostedJson; } });\nexports.discovery = __importStar(require(\"./lib/discovery\"));\nexports.enr = __importStar(require(\"./lib/enr\"));\nexports.utils = __importStar(require(\"./lib/utils\"));\nexports.waku = __importStar(require(\"./lib/waku\"));\nvar waku_1 = require(\"./lib/waku\");\nObject.defineProperty(exports, \"Waku\", { enumerable: true, get: function () { return waku_1.Waku; } });\nObject.defineProperty(exports, \"DefaultPubSubTopic\", { enumerable: true, get: function () { return waku_1.DefaultPubSubTopic; } });\nexports.waku_message = __importStar(require(\"./lib/waku_message\"));\nvar waku_message_1 = require(\"./lib/waku_message\");\nObject.defineProperty(exports, \"WakuMessage\", { enumerable: true, get: function () { return waku_message_1.WakuMessage; } });\nvar version_1_1 = require(\"./lib/waku_message/version_1\");\nObject.defineProperty(exports, \"generatePrivateKey\", { enumerable: true, get: function () { return version_1_1.generatePrivateKey; } });\nObject.defineProperty(exports, \"generateSymmetricKey\", { enumerable: true, get: function () { return version_1_1.generateSymmetricKey; } });\nObject.defineProperty(exports, \"getPublicKey\", { enumerable: true, get: function () { return version_1_1.getPublicKey; } });\nexports.waku_light_push = __importStar(require(\"./lib/waku_light_push\"));\nvar waku_light_push_1 = require(\"./lib/waku_light_push\");\nObject.defineProperty(exports, \"WakuLightPush\", { enumerable: true, get: function () { return waku_light_push_1.WakuLightPush; } });\nObject.defineProperty(exports, \"LightPushCodec\", { enumerable: true, get: function () { return waku_light_push_1.LightPushCodec; } });\nObject.defineProperty(exports, \"PushResponse\", { enumerable: true, get: function () { return waku_light_push_1.PushResponse; } });\nexports.waku_relay = __importStar(require(\"./lib/waku_relay\"));\nvar waku_relay_1 = require(\"./lib/waku_relay\");\nObject.defineProperty(exports, \"WakuRelay\", { enumerable: true, get: function () { return waku_relay_1.WakuRelay; } });\nObject.defineProperty(exports, \"RelayCodecs\", { enumerable: true, get: function () { return waku_relay_1.RelayCodecs; } });\nexports.waku_store = __importStar(require(\"./lib/waku_store\"));\nvar waku_store_1 = require(\"./lib/waku_store\");\nObject.defineProperty(exports, \"PageDirection\", { enumerable: true, get: function () { return waku_store_1.PageDirection; } });\nObject.defineProperty(exports, \"WakuStore\", { enumerable: true, get: function () { return waku_store_1.WakuStore; } });\nObject.defineProperty(exports, \"StoreCodec\", { enumerable: true, get: function () { return waku_store_1.StoreCodec; } });\nexports.proto = __importStar(require(\"./proto\"));\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getPseudoRandomSubset = exports.ENRTree = exports.DnsOverHttps = exports.DnsNodeDiscovery = exports.Bootstrap = exports.getNodesFromHostedJson = void 0;\nconst utils_1 = require(\"libp2p-gossipsub/src/utils\");\nvar hosted_json_1 = require(\"./hosted_json\");\nObject.defineProperty(exports, \"getNodesFromHostedJson\", { enumerable: true, get: function () { return hosted_json_1.getNodesFromHostedJson; } });\nvar bootstrap_1 = require(\"./bootstrap\");\nObject.defineProperty(exports, \"Bootstrap\", { enumerable: true, get: function () { return bootstrap_1.Bootstrap; } });\nvar dns_1 = require(\"./dns\");\nObject.defineProperty(exports, \"DnsNodeDiscovery\", { enumerable: true, get: function () { return dns_1.DnsNodeDiscovery; } });\nvar dns_over_https_1 = require(\"./dns_over_https\");\nObject.defineProperty(exports, \"DnsOverHttps\", { enumerable: true, get: function () { return dns_over_https_1.DnsOverHttps; } });\nvar enrtree_1 = require(\"./enrtree\");\nObject.defineProperty(exports, \"ENRTree\", { enumerable: true, get: function () { return enrtree_1.ENRTree; } });\nfunction getPseudoRandomSubset(values, wantedNumber) {\n    if (values.length <= wantedNumber) {\n        return values;\n    }\n    return utils_1.shuffle(values).slice(0, wantedNumber);\n}\nexports.getPseudoRandomSubset = getPseudoRandomSubset;\n//# sourceMappingURL=index.js.map","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Waku = exports.DefaultPubSubTopic = exports.DefaultRelayKeepAliveValueSecs = exports.DefaultPingKeepAliveValueSecs = void 0;\nconst noise_1 = require(\"@chainsafe/libp2p-noise/dist/src/noise\");\nconst debug_1 = __importDefault(require(\"debug\"));\nconst libp2p_1 = __importDefault(require(\"libp2p\"));\nconst libp2p_bootstrap_1 = __importDefault(require(\"libp2p-bootstrap\"));\n// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n// @ts-ignore: No types available\nconst libp2p_mplex_1 = __importDefault(require(\"libp2p-mplex\"));\n// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n// @ts-ignore: No types available\nconst libp2p_websockets_1 = __importDefault(require(\"libp2p-websockets\"));\n// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n// @ts-ignore: No types available\nconst filters_1 = __importDefault(require(\"libp2p-websockets/src/filters\"));\nconst ping_1 = __importDefault(require(\"libp2p/src/ping\"));\nconst multiaddr_1 = require(\"multiaddr\");\nconst peer_id_1 = __importDefault(require(\"peer-id\"));\nconst discovery_1 = require(\"./discovery\");\nconst select_peer_1 = require(\"./select_peer\");\nconst waku_light_push_1 = require(\"./waku_light_push\");\nconst waku_message_1 = require(\"./waku_message\");\nconst waku_relay_1 = require(\"./waku_relay\");\nconst constants_1 = require(\"./waku_relay/constants\");\nconst waku_store_1 = require(\"./waku_store\");\nconst websocketsTransportKey = libp2p_websockets_1.default.prototype[Symbol.toStringTag];\nexports.DefaultPingKeepAliveValueSecs = 0;\nexports.DefaultRelayKeepAliveValueSecs = 5 * 60;\n/**\n * DefaultPubSubTopic is the default gossipsub topic to use for Waku.\n */\nexports.DefaultPubSubTopic = '/waku/2/default-waku/proto';\nconst dbg = debug_1.default('waku:waku');\nclass Waku {\n    constructor(options, libp2p, store, lightPush) {\n        this.libp2p = libp2p;\n        this.relay = libp2p.pubsub;\n        this.store = store;\n        this.lightPush = lightPush;\n        this.pingKeepAliveTimers = {};\n        this.relayKeepAliveTimers = {};\n        const pingKeepAlive = options.pingKeepAlive || exports.DefaultPingKeepAliveValueSecs;\n        const relayKeepAlive = options.relayKeepAlive || exports.DefaultRelayKeepAliveValueSecs;\n        libp2p.connectionManager.on('peer:connect', (connection) => {\n            this.startKeepAlive(connection.remotePeer, pingKeepAlive, relayKeepAlive);\n        });\n        libp2p.connectionManager.on('peer:disconnect', (connection) => {\n            this.stopKeepAlive(connection.remotePeer);\n        });\n        options?.decryptionKeys?.forEach((key) => {\n            this.addDecryptionKey(key);\n        });\n    }\n    /**\n     * Create new waku node\n     *\n     * @param options Takes the same options than `Libp2p`.\n     */\n    static async create(options) {\n        // Get an object in case options or libp2p are undefined\n        const libp2pOpts = Object.assign({}, options?.libp2p);\n        // Default for Websocket filter is `all`:\n        // Returns all TCP and DNS based addresses, both with ws or wss.\n        libp2pOpts.config = Object.assign({\n            transport: {\n                [websocketsTransportKey]: {\n                    filter: filters_1.default.all,\n                },\n            },\n        }, options?.libp2p?.config);\n        // Pass pubsub topic to relay\n        if (options?.pubSubTopic) {\n            libp2pOpts.config.pubsub = Object.assign({ pubSubTopic: options.pubSubTopic }, libp2pOpts.config.pubsub);\n        }\n        libp2pOpts.modules = Object.assign({}, options?.libp2p?.modules);\n        // Default transport for libp2p is Websockets\n        libp2pOpts.modules = Object.assign({\n            transport: [libp2p_websockets_1.default],\n        }, options?.libp2p?.modules);\n        // streamMuxer, connection encryption and pubsub are overridden\n        // as those are the only ones currently supported by Waku nodes.\n        libp2pOpts.modules = Object.assign(libp2pOpts.modules, {\n            streamMuxer: [libp2p_mplex_1.default],\n            connEncryption: [new noise_1.Noise(options?.staticNoiseKey)],\n            pubsub: waku_relay_1.WakuRelay,\n        });\n        if (options?.bootstrap) {\n            const bootstrap = new discovery_1.Bootstrap(options?.bootstrap);\n            if (bootstrap.getBootstrapPeers !== undefined) {\n                try {\n                    const list = await bootstrap.getBootstrapPeers();\n                    // Note: this overrides any other peer discover\n                    libp2pOpts.modules = Object.assign(libp2pOpts.modules, {\n                        peerDiscovery: [libp2p_bootstrap_1.default],\n                    });\n                    libp2pOpts.config.peerDiscovery = {\n                        [libp2p_bootstrap_1.default.tag]: {\n                            list,\n                            enabled: true,\n                        },\n                    };\n                }\n                catch (e) {\n                    dbg('Failed to retrieve bootstrap nodes', e);\n                }\n            }\n        }\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore: modules property is correctly set thanks to voodoo\n        const libp2p = await libp2p_1.default.create(libp2pOpts);\n        const wakuStore = new waku_store_1.WakuStore(libp2p, {\n            pubSubTopic: options?.pubSubTopic,\n        });\n        const wakuLightPush = new waku_light_push_1.WakuLightPush(libp2p);\n        await libp2p.start();\n        return new Waku(options ? options : {}, libp2p, wakuStore, wakuLightPush);\n    }\n    /**\n     * Dials to the provided peer.\n     *\n     * @param peer The peer to dial\n     */\n    async dial(peer) {\n        return this.libp2p.dialProtocol(peer, [waku_store_1.StoreCodec].concat(waku_relay_1.RelayCodecs));\n    }\n    /**\n     * Add peer to address book, it will be auto-dialed in the background.\n     */\n    addPeerToAddressBook(peerId, multiaddrs) {\n        let peer;\n        if (typeof peerId === 'string') {\n            peer = peer_id_1.default.createFromB58String(peerId);\n        }\n        else {\n            peer = peerId;\n        }\n        const addresses = multiaddrs.map((addr) => {\n            if (typeof addr === 'string') {\n                return multiaddr_1.multiaddr(addr);\n            }\n            else {\n                return addr;\n            }\n        });\n        this.libp2p.peerStore.addressBook.set(peer, addresses);\n    }\n    async stop() {\n        return this.libp2p.stop();\n    }\n    /**\n     * Register a decryption key to attempt decryption of messages received via\n     * [[WakuRelay]] and [[WakuStore]]. This can either be a private key for\n     * asymmetric encryption or a symmetric key.\n     *\n     * Strings must be in hex format.\n     */\n    addDecryptionKey(key, options) {\n        this.relay.addDecryptionKey(key, options);\n        this.store.addDecryptionKey(key, options);\n    }\n    /**\n     * Delete a decryption key that was used to attempt decryption of messages\n     * received via [[WakuRelay]] or [[WakuStore]].\n     *\n     * Strings must be in hex format.\n     */\n    deleteDecryptionKey(key) {\n        this.relay.deleteDecryptionKey(key);\n        this.store.deleteDecryptionKey(key);\n    }\n    /**\n     * Return the local multiaddr with peer id on which libp2p is listening.\n     * @throws if libp2p is not listening on localhost\n     */\n    getLocalMultiaddrWithID() {\n        const localMultiaddr = this.libp2p.multiaddrs.find((addr) => addr.toString().match(/127\\.0\\.0\\.1/));\n        if (!localMultiaddr || localMultiaddr.toString() === '') {\n            throw 'Not listening on localhost';\n        }\n        return localMultiaddr + '/p2p/' + this.libp2p.peerId.toB58String();\n    }\n    /**\n     * Wait to be connected to a peer. Useful when using the [[CreateOptions.bootstrap]]\n     * with [[Waku.create]]. The Promise resolves only once we are connected to a\n     * Store peer, Relay peer and Light Push peer.\n     */\n    async waitForConnectedPeer() {\n        const desiredProtocols = [[waku_store_1.StoreCodec], [waku_light_push_1.LightPushCodec], waku_relay_1.RelayCodecs];\n        await Promise.all(desiredProtocols.map((desiredProtocolVersions) => {\n            const peers = new Array();\n            desiredProtocolVersions.forEach((proto) => {\n                select_peer_1.getPeersForProtocol(this.libp2p, proto).forEach((peer) => peers.push(peer));\n            });\n            if (peers.length > 0) {\n                return Promise.resolve();\n            }\n            else {\n                // No peer available for this protocol, waiting to connect to one.\n                return new Promise((resolve) => {\n                    this.libp2p.peerStore.on('change:protocols', ({ protocols: connectedPeerProtocols }) => {\n                        desiredProtocolVersions.forEach((desiredProto) => {\n                            if (connectedPeerProtocols.includes(desiredProto)) {\n                                dbg('Resolving for', desiredProto, connectedPeerProtocols);\n                                resolve();\n                            }\n                        });\n                    });\n                });\n            }\n        }));\n    }\n    startKeepAlive(peerId, pingPeriodSecs, relayPeriodSecs) {\n        // Just in case a timer already exist for this peer\n        this.stopKeepAlive(peerId);\n        const peerIdStr = peerId.toB58String();\n        if (pingPeriodSecs !== 0) {\n            this.pingKeepAliveTimers[peerIdStr] = setInterval(() => {\n                ping_1.default(this.libp2p, peerId);\n            }, pingPeriodSecs * 1000);\n        }\n        if (relayPeriodSecs !== 0) {\n            this.relayKeepAliveTimers[peerIdStr] = setInterval(() => {\n                waku_message_1.WakuMessage.fromBytes(new Uint8Array(), constants_1.RelayPingContentTopic).then((wakuMsg) => this.relay.send(wakuMsg));\n            }, relayPeriodSecs * 1000);\n        }\n    }\n    stopKeepAlive(peerId) {\n        const peerIdStr = peerId.toB58String();\n        if (this.pingKeepAliveTimers[peerIdStr]) {\n            clearInterval(this.pingKeepAliveTimers[peerIdStr]);\n            delete this.pingKeepAliveTimers[peerIdStr];\n        }\n        if (this.relayKeepAliveTimers[peerIdStr]) {\n            clearInterval(this.relayKeepAliveTimers[peerIdStr]);\n            delete this.relayKeepAliveTimers[peerIdStr];\n        }\n    }\n}\nexports.Waku = Waku;\n//# sourceMappingURL=waku.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.WakuMessage = exports.DecryptionMethod = void 0;\n// Ensure that this class matches the proto interface while\nconst buffer_1 = require(\"buffer\");\nconst debug_1 = __importDefault(require(\"debug\"));\nconst minimal_1 = require(\"protobufjs/minimal\");\n// Protecting the user from protobuf oddities\nconst proto = __importStar(require(\"../../proto/waku/v2/message\"));\nconst version_1 = __importStar(require(\"./version_1\"));\nconst DefaultVersion = 0;\nconst dbg = debug_1.default('waku:message');\nvar DecryptionMethod;\n(function (DecryptionMethod) {\n    DecryptionMethod[\"Asymmetric\"] = \"asymmetric\";\n    DecryptionMethod[\"Symmetric\"] = \"symmetric\";\n})(DecryptionMethod = exports.DecryptionMethod || (exports.DecryptionMethod = {}));\nclass WakuMessage {\n    constructor(proto, _signaturePublicKey, _signature) {\n        this.proto = proto;\n        this._signaturePublicKey = _signaturePublicKey;\n        this._signature = _signature;\n    }\n    /**\n     * Create Message with an utf-8 string as payload.\n     */\n    static async fromUtf8String(utf8, contentTopic, opts) {\n        const payload = buffer_1.Buffer.from(utf8, 'utf-8');\n        return WakuMessage.fromBytes(payload, contentTopic, opts);\n    }\n    /**\n     * Create a Waku Message with the given payload.\n     *\n     * By default, the payload is kept clear (version 0).\n     * If `opts.encPublicKey` is passed, the payload is encrypted using\n     * asymmetric encryption (version 1).\n     *\n     * If `opts.sigPrivKey` is passed and version 1 is used, the payload is signed\n     * before encryption.\n     *\n     * @throws if both `opts.encPublicKey` and `opt.symKey` are passed\n     */\n    static async fromBytes(payload, contentTopic, opts) {\n        const { timestamp, encPublicKey, symKey, sigPrivKey } = Object.assign({ timestamp: new Date() }, opts ? opts : {});\n        let _payload = payload;\n        let version = DefaultVersion;\n        let sig;\n        if (encPublicKey && symKey) {\n            throw 'Pass either `encPublicKey` or `symKey`, not both.';\n        }\n        if (encPublicKey) {\n            const enc = version_1.clearEncode(_payload, sigPrivKey);\n            _payload = await version_1.encryptAsymmetric(enc.payload, encPublicKey);\n            sig = enc.sig;\n            version = 1;\n        }\n        else if (symKey) {\n            const enc = version_1.clearEncode(_payload, sigPrivKey);\n            _payload = await version_1.encryptSymmetric(enc.payload, symKey);\n            sig = enc.sig;\n            version = 1;\n        }\n        return new WakuMessage({\n            payload: _payload,\n            timestamp: timestamp.valueOf() / 1000,\n            version,\n            contentTopic,\n        }, sig?.publicKey, sig?.signature);\n    }\n    /**\n     * Decode a byte array into Waku Message.\n     *\n     * @params bytes The message encoded using protobuf as defined in [14/WAKU2-MESSAGE](https://rfc.vac.dev/spec/14/).\n     * @params decryptionKeys If the payload is encrypted (version = 1), then the\n     * keys are used to attempt decryption of the message. The passed key can either\n     * be asymmetric private keys or symmetric keys, both method are tried for each\n     * key until the message is decrypted or combinations are run out.\n     */\n    static async decode(bytes, decryptionKeys) {\n        const protoBuf = proto.WakuMessage.decode(minimal_1.Reader.create(bytes));\n        return WakuMessage.decodeProto(protoBuf, decryptionKeys);\n    }\n    /**\n     * Decode and decrypt Waku Message Protobuf Object into Waku Message.\n     *\n     * @params protoBuf The message to decode and decrypt.\n     * @params decryptionKeys If the payload is encrypted (version = 1), then the\n     * keys are used to attempt decryption of the message. The passed key can either\n     * be asymmetric private keys or symmetric keys, both method are tried for each\n     * key until the message is decrypted or combinations are run out.\n     */\n    static async decodeProto(protoBuf, decryptionKeys) {\n        if (protoBuf.payload === undefined) {\n            dbg('Payload is undefined');\n            return;\n        }\n        const payload = protoBuf.payload;\n        let signaturePublicKey;\n        let signature;\n        if (protoBuf.version === 1 && protoBuf.payload) {\n            if (decryptionKeys === undefined) {\n                dbg('Payload is encrypted but no private keys have been provided.');\n                return;\n            }\n            // Returns a bunch of `undefined` and hopefully one decrypted result\n            const allResults = await Promise.all(decryptionKeys.map(async ({ key, method, contentTopics }) => {\n                if (!contentTopics ||\n                    (protoBuf.contentTopic &&\n                        contentTopics.includes(protoBuf.contentTopic))) {\n                    switch (method) {\n                        case DecryptionMethod.Asymmetric:\n                            try {\n                                return await version_1.decryptAsymmetric(payload, key);\n                            }\n                            catch (e) {\n                                dbg('Failed to decrypt message using symmetric encryption despite decryption method being specified', e);\n                                return;\n                            }\n                        case DecryptionMethod.Symmetric:\n                            try {\n                                return await version_1.decryptSymmetric(payload, key);\n                            }\n                            catch (e) {\n                                dbg('Failed to decrypt message using asymmetric encryption despite decryption method being specified', e);\n                                return;\n                            }\n                        default:\n                            try {\n                                return await version_1.decryptSymmetric(payload, key);\n                            }\n                            catch (e) {\n                                dbg('Failed to decrypt message using symmetric encryption', e);\n                                try {\n                                    return await version_1.decryptAsymmetric(payload, key);\n                                }\n                                catch (e) {\n                                    dbg('Failed to decrypt message using asymmetric encryption', e);\n                                    return;\n                                }\n                            }\n                    }\n                }\n                else {\n                    // No key available for this content topic\n                    return;\n                }\n            }));\n            const isDefined = (dec) => {\n                return !!dec;\n            };\n            const decodedResults = allResults.filter(isDefined);\n            if (decodedResults.length === 0) {\n                dbg('Failed to decrypt payload.');\n                return;\n            }\n            const dec = decodedResults[0];\n            const res = await version_1.clearDecode(dec);\n            if (!res) {\n                dbg('Failed to decode payload.');\n                return;\n            }\n            Object.assign(protoBuf, { payload: res.payload });\n            signaturePublicKey = res.sig?.publicKey;\n            signature = res.sig?.signature;\n        }\n        return new WakuMessage(protoBuf, signaturePublicKey, signature);\n    }\n    encode() {\n        return proto.WakuMessage.encode(this.proto).finish();\n    }\n    get payloadAsUtf8() {\n        if (!this.proto.payload) {\n            return '';\n        }\n        return buffer_1.Buffer.from(this.proto.payload).toString('utf-8');\n    }\n    get payload() {\n        return this.proto.payload;\n    }\n    get contentTopic() {\n        return this.proto.contentTopic;\n    }\n    get version() {\n        return this.proto.version;\n    }\n    get timestamp() {\n        if (this.proto.timestamp) {\n            return new Date(this.proto.timestamp * 1000);\n        }\n        return;\n    }\n    /**\n     * The public key used to sign the message.\n     *\n     * MAY be present if the message is version 1.\n     */\n    get signaturePublicKey() {\n        return this._signaturePublicKey;\n    }\n    /**\n     * The signature of the message.\n     *\n     * MAY be present if the message is version 1.\n     */\n    get signature() {\n        return this._signature;\n    }\n}\nexports.WakuMessage = WakuMessage;\n//# sourceMappingURL=index.js.map","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.WakuMessage = exports.protobufPackage = void 0;\n/* eslint-disable */\nconst long_1 = __importDefault(require(\"long\"));\nconst minimal_1 = __importDefault(require(\"protobufjs/minimal\"));\nexports.protobufPackage = 'waku.v2';\nfunction createBaseWakuMessage() {\n    return {\n        payload: undefined,\n        contentTopic: undefined,\n        version: undefined,\n        timestamp: undefined,\n    };\n}\nexports.WakuMessage = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.payload !== undefined) {\n            writer.uint32(10).bytes(message.payload);\n        }\n        if (message.contentTopic !== undefined) {\n            writer.uint32(18).string(message.contentTopic);\n        }\n        if (message.version !== undefined) {\n            writer.uint32(24).uint32(message.version);\n        }\n        if (message.timestamp !== undefined) {\n            writer.uint32(33).double(message.timestamp);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseWakuMessage();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.payload = reader.bytes();\n                    break;\n                case 2:\n                    message.contentTopic = reader.string();\n                    break;\n                case 3:\n                    message.version = reader.uint32();\n                    break;\n                case 4:\n                    message.timestamp = reader.double();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            payload: isSet(object.payload)\n                ? bytesFromBase64(object.payload)\n                : undefined,\n            contentTopic: isSet(object.contentTopic)\n                ? String(object.contentTopic)\n                : undefined,\n            version: isSet(object.version) ? Number(object.version) : undefined,\n            timestamp: isSet(object.timestamp) ? Number(object.timestamp) : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.payload !== undefined &&\n            (obj.payload =\n                message.payload !== undefined\n                    ? base64FromBytes(message.payload)\n                    : undefined);\n        message.contentTopic !== undefined &&\n            (obj.contentTopic = message.contentTopic);\n        message.version !== undefined &&\n            (obj.version = Math.round(message.version));\n        message.timestamp !== undefined && (obj.timestamp = message.timestamp);\n        return obj;\n    },\n    fromPartial(object) {\n        const message = createBaseWakuMessage();\n        message.payload = object.payload ?? undefined;\n        message.contentTopic = object.contentTopic ?? undefined;\n        message.version = object.version ?? undefined;\n        message.timestamp = object.timestamp ?? undefined;\n        return message;\n    },\n};\nvar globalThis = (() => {\n    if (typeof globalThis !== 'undefined')\n        return globalThis;\n    if (typeof self !== 'undefined')\n        return self;\n    if (typeof window !== 'undefined')\n        return window;\n    if (typeof global !== 'undefined')\n        return global;\n    throw 'Unable to locate global object';\n})();\nconst atob = globalThis.atob ||\n    ((b64) => globalThis.Buffer.from(b64, 'base64').toString('binary'));\nfunction bytesFromBase64(b64) {\n    const bin = atob(b64);\n    const arr = new Uint8Array(bin.length);\n    for (let i = 0; i < bin.length; ++i) {\n        arr[i] = bin.charCodeAt(i);\n    }\n    return arr;\n}\nconst btoa = globalThis.btoa ||\n    ((bin) => globalThis.Buffer.from(bin, 'binary').toString('base64'));\nfunction base64FromBytes(arr) {\n    const bin = [];\n    for (const byte of arr) {\n        bin.push(String.fromCharCode(byte));\n    }\n    return btoa(bin.join(''));\n}\nif (minimal_1.default.util.Long !== long_1.default) {\n    minimal_1.default.util.Long = long_1.default;\n    minimal_1.default.configure();\n}\nfunction isSet(value) {\n    return value !== null && value !== undefined;\n}\n//# sourceMappingURL=message.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.WakuRelay = exports.RelayCodecs = void 0;\nconst debug_1 = __importDefault(require(\"debug\"));\nconst libp2p_gossipsub_1 = __importDefault(require(\"libp2p-gossipsub\"));\nconst utils_1 = require(\"libp2p-gossipsub/src/utils\");\nconst signature_policy_1 = require(\"libp2p-interfaces/src/pubsub/signature-policy\");\nconst peer_id_1 = __importDefault(require(\"peer-id\"));\nconst utils_2 = require(\"../utils\");\nconst waku_1 = require(\"../waku\");\nconst waku_message_1 = require(\"../waku_message\");\nconst constants = __importStar(require(\"./constants\"));\nconst constants_1 = require(\"./constants\");\nObject.defineProperty(exports, \"RelayCodecs\", { enumerable: true, get: function () { return constants_1.RelayCodecs; } });\nconst get_relay_peers_1 = require(\"./get_relay_peers\");\nconst relay_heartbeat_1 = require(\"./relay_heartbeat\");\nconst dbg = debug_1.default('waku:relay');\n/**\n * Implements the [Waku v2 Relay protocol]{@link https://rfc.vac.dev/spec/11/}.\n * Must be passed as a `pubsub` module to a {Libp2p} instance.\n *\n * @implements {require('libp2p-interfaces/src/pubsub')}\n * @noInheritDoc\n */\nclass WakuRelay extends libp2p_gossipsub_1.default {\n    constructor(libp2p, options) {\n        super(libp2p, Object.assign(options, {\n            // Ensure that no signature is included nor expected in the messages.\n            globalSignaturePolicy: signature_policy_1.SignaturePolicy.StrictNoSign,\n        }));\n        this.heartbeat = new relay_heartbeat_1.RelayHeartbeat(this);\n        this.observers = {};\n        this.decryptionKeys = new Map();\n        const multicodecs = constants.RelayCodecs;\n        Object.assign(this, { multicodecs });\n        this.pubSubTopic = options?.pubSubTopic || waku_1.DefaultPubSubTopic;\n        options?.decryptionKeys?.forEach((key) => {\n            this.addDecryptionKey(key);\n        });\n    }\n    /**\n     * Mounts the gossipsub protocol onto the libp2p node\n     * and subscribes to the default topic.\n     *\n     * @override\n     * @returns {void}\n     */\n    start() {\n        super.start();\n        this.subscribe(this.pubSubTopic);\n    }\n    /**\n     * Send Waku message.\n     *\n     * @param {WakuMessage} message\n     * @returns {Promise<void>}\n     */\n    async send(message) {\n        const msg = message.encode();\n        await super.publish(this.pubSubTopic, Buffer.from(msg));\n    }\n    /**\n     * Register a decryption key to attempt decryption of received messages.\n     * This can either be a private key for asymmetric encryption or a symmetric\n     * key. `WakuRelay` will attempt to decrypt messages using both methods.\n     *\n     * Strings must be in hex format.\n     */\n    addDecryptionKey(key, options) {\n        this.decryptionKeys.set(utils_2.hexToBuf(key), options ?? {});\n    }\n    /**\n     * Delete a decryption key that was used to attempt decryption of received\n     * messages.\n     *\n     * Strings must be in hex format.\n     */\n    deleteDecryptionKey(key) {\n        this.decryptionKeys.delete(utils_2.hexToBuf(key));\n    }\n    /**\n     * Register an observer of new messages received via waku relay\n     *\n     * @param callback called when a new message is received via waku relay\n     * @param contentTopics Content Topics for which the callback with be called,\n     * all of them if undefined, [] or [\"\",..] is passed.\n     * @returns {void}\n     */\n    addObserver(callback, contentTopics = []) {\n        if (contentTopics.length === 0) {\n            if (!this.observers['']) {\n                this.observers[''] = new Set();\n            }\n            this.observers[''].add(callback);\n        }\n        else {\n            contentTopics.forEach((contentTopic) => {\n                if (!this.observers[contentTopic]) {\n                    this.observers[contentTopic] = new Set();\n                }\n                this.observers[contentTopic].add(callback);\n            });\n        }\n    }\n    /**\n     * Remove an observer of new messages received via waku relay.\n     * Useful to ensure the same observer is not registered several time\n     * (e.g when loading React components)\n     */\n    deleteObserver(callback, contentTopics = []) {\n        if (contentTopics.length === 0) {\n            if (this.observers['']) {\n                this.observers[''].delete(callback);\n            }\n        }\n        else {\n            contentTopics.forEach((contentTopic) => {\n                if (this.observers[contentTopic]) {\n                    this.observers[contentTopic].delete(callback);\n                }\n            });\n        }\n    }\n    /**\n     * Return the relay peers we are connected to and we would publish a message to\n     */\n    getPeers() {\n        return get_relay_peers_1.getRelayPeers(this, this.pubSubTopic, this._options.D, (id) => {\n            // Filter peers we would not publish to\n            return (this.score.score(id) >= this._options.scoreThresholds.publishThreshold);\n        });\n    }\n    /**\n     * Subscribe to a pubsub topic and start emitting Waku messages to observers.\n     *\n     * @override\n     */\n    subscribe(pubSubTopic) {\n        this.on(pubSubTopic, (event) => {\n            const decryptionKeys = Array.from(this.decryptionKeys).map(([key, { method, contentTopics }]) => {\n                return {\n                    key,\n                    method,\n                    contentTopics,\n                };\n            });\n            dbg(`Message received on ${pubSubTopic}`);\n            waku_message_1.WakuMessage.decode(event.data, decryptionKeys)\n                .then((wakuMsg) => {\n                if (!wakuMsg) {\n                    dbg('Failed to decode Waku Message');\n                    return;\n                }\n                if (this.observers['']) {\n                    this.observers[''].forEach((callbackFn) => {\n                        callbackFn(wakuMsg);\n                    });\n                }\n                if (wakuMsg.contentTopic) {\n                    if (this.observers[wakuMsg.contentTopic]) {\n                        this.observers[wakuMsg.contentTopic].forEach((callbackFn) => {\n                            callbackFn(wakuMsg);\n                        });\n                    }\n                }\n            })\n                .catch((e) => {\n                dbg('Failed to decode Waku Message', e);\n            });\n        });\n        super.subscribe(pubSubTopic);\n    }\n    /**\n     * Join pubsub topic.\n     * This is present to override the behavior of Gossipsub and should not\n     * be used by API Consumers\n     *\n     * @internal\n     * @param {string} topic\n     * @returns {void}\n     * @override\n     */\n    join(topic) {\n        if (!this.started) {\n            throw new Error('WakuRelayPubSub has not started');\n        }\n        const fanoutPeers = this.fanout.get(topic);\n        if (fanoutPeers) {\n            // these peers have a score above the publish threshold, which may be negative\n            // so drop the ones with a negative score\n            fanoutPeers.forEach((id) => {\n                if (this.score.score(id) < 0) {\n                    fanoutPeers.delete(id);\n                }\n            });\n            if (fanoutPeers.size < this._options.D) {\n                // we need more peers; eager, as this would get fixed in the next heartbeat\n                get_relay_peers_1.getRelayPeers(this, topic, this._options.D - fanoutPeers.size, (id) => {\n                    // filter our current peers, direct peers, and peers with negative scores\n                    return (!fanoutPeers.has(id) &&\n                        !this.direct.has(id) &&\n                        this.score.score(id) >= 0);\n                }).forEach((id) => fanoutPeers.add(id));\n            }\n            this.mesh.set(topic, fanoutPeers);\n            this.fanout.delete(topic);\n            this.lastpub.delete(topic);\n        }\n        else {\n            const peers = get_relay_peers_1.getRelayPeers(this, topic, this._options.D, (id) => {\n                // filter direct peers and peers with negative score\n                return !this.direct.has(id) && this.score.score(id) >= 0;\n            });\n            this.mesh.set(topic, peers);\n        }\n        this.mesh.get(topic)?.forEach((id) => {\n            this.log('JOIN: Add mesh link to %s in %s', id, topic);\n            this._sendGraft(id, topic);\n        });\n    }\n    /**\n     * Publish messages.\n     * This is present to override the behavior of Gossipsub and should not\n     * be used by API Consumers\n     *\n     * @ignore\n     * @override\n     * @param {InMessage} msg\n     * @returns {void}\n     */\n    async _publish(msg) {\n        if (msg.receivedFrom !== this.peerId.toB58String()) {\n            this.score.deliverMessage(msg);\n            this.gossipTracer.deliverMessage(msg);\n        }\n        const msgID = await this.getMsgId(msg);\n        const msgIdStr = utils_1.messageIdToString(msgID);\n        // put in seen cache\n        this.seenCache.put(msgIdStr);\n        this.messageCache.put(msg);\n        const toSend = new Set();\n        msg.topicIDs.forEach((topic) => {\n            const peersInTopic = this.topics.get(topic);\n            if (!peersInTopic) {\n                return;\n            }\n            // direct peers\n            this.direct.forEach((id) => {\n                toSend.add(id);\n            });\n            let meshPeers = this.mesh.get(topic);\n            if (!meshPeers || !meshPeers.size) {\n                // We are not in the mesh for topic, use fanout peers\n                meshPeers = this.fanout.get(topic);\n                if (!meshPeers) {\n                    // If we are not in the fanout, then pick peers in topic above the publishThreshold\n                    const peers = get_relay_peers_1.getRelayPeers(this, topic, this._options.D, (id) => {\n                        return (this.score.score(id) >=\n                            this._options.scoreThresholds.publishThreshold);\n                    });\n                    if (peers.size > 0) {\n                        meshPeers = peers;\n                        this.fanout.set(topic, peers);\n                    }\n                    else {\n                        meshPeers = new Set();\n                    }\n                }\n                // Store the latest publishing time\n                this.lastpub.set(topic, this._now());\n            }\n            meshPeers?.forEach((peer) => {\n                toSend.add(peer);\n            });\n        });\n        // Publish messages to peers\n        const rpc = utils_1.createGossipRpc([libp2p_gossipsub_1.default.utils.normalizeOutRpcMessage(msg)]);\n        toSend.forEach((id) => {\n            if (id === msg.from) {\n                return;\n            }\n            this._sendRpc(id, rpc);\n        });\n    }\n    /**\n     * Emits gossip to peers in a particular topic.\n     *\n     * This is present to override the behavior of Gossipsub and should not\n     * be used by API Consumers\n     *\n     * @ignore\n     * @override\n     * @param {string} topic\n     * @param {Set<string>} exclude peers to exclude\n     * @returns {void}\n     */\n    _emitGossip(topic, exclude) {\n        const messageIDs = this.messageCache.getGossipIDs(topic);\n        if (!messageIDs.length) {\n            return;\n        }\n        // shuffle to emit in random order\n        utils_1.shuffle(messageIDs);\n        // if we are emitting more than GossipsubMaxIHaveLength ids, truncate the list\n        if (messageIDs.length > constants.RelayMaxIHaveLength) {\n            // we do the truncation (with shuffling) per peer below\n            this.log('too many messages for gossip; will truncate IHAVE list (%d messages)', messageIDs.length);\n        }\n        // Send gossip to GossipFactor peers above threshold with a minimum of D_lazy\n        // First we collect the peers above gossipThreshold that are not in the exclude set\n        // and then randomly select from that set\n        // We also exclude direct peers, as there is no reason to emit gossip to them\n        const peersToGossip = [];\n        const topicPeers = this.topics.get(topic);\n        if (!topicPeers) {\n            // no topic peers, no gossip\n            return;\n        }\n        topicPeers.forEach((id) => {\n            const peerStreams = this.peers.get(id);\n            if (!peerStreams) {\n                return;\n            }\n            if (!exclude.has(id) &&\n                !this.direct.has(id) &&\n                constants.RelayCodecs.includes(peerStreams.protocol) &&\n                this.score.score(id) >= this._options.scoreThresholds.gossipThreshold) {\n                peersToGossip.push(id);\n            }\n        });\n        let target = this._options.Dlazy;\n        const factor = constants.RelayGossipFactor * peersToGossip.length;\n        if (factor > target) {\n            target = factor;\n        }\n        if (target > peersToGossip.length) {\n            target = peersToGossip.length;\n        }\n        else {\n            utils_1.shuffle(peersToGossip);\n        }\n        // Emit the IHAVE gossip to the selected peers up to the target\n        peersToGossip.slice(0, target).forEach((id) => {\n            let peerMessageIDs = messageIDs;\n            if (messageIDs.length > constants.RelayMaxIHaveLength) {\n                // shuffle and slice message IDs per peer so that we emit a different set for each peer\n                // we have enough redundancy in the system that this will significantly increase the message\n                // coverage when we do truncate\n                peerMessageIDs = utils_1.shuffle(peerMessageIDs.slice()).slice(0, constants.RelayMaxIHaveLength);\n            }\n            this._pushGossip(id, {\n                topicID: topic,\n                messageIDs: peerMessageIDs,\n            });\n        });\n    }\n    /**\n     * Make a PRUNE control message for a peer in a topic.\n     * This is present to override the behavior of Gossipsub and should not\n     * be used by API Consumers\n     *\n     * @ignore\n     * @override\n     * @param {string} id\n     * @param {string} topic\n     * @param {boolean} doPX\n     * @returns {RPC.IControlPrune}\n     */\n    _makePrune(id, topic, doPX) {\n        // backoff is measured in seconds\n        // RelayPruneBackoff is measured in milliseconds\n        const backoff = constants.RelayPruneBackoff / 1000;\n        const px = [];\n        if (doPX) {\n            // select peers for Peer eXchange\n            const peers = get_relay_peers_1.getRelayPeers(this, topic, constants.RelayPrunePeers, (xid) => {\n                return xid !== id && this.score.score(xid) >= 0;\n            });\n            peers.forEach((p) => {\n                // see if we have a signed record to send back; if we don't, just send\n                // the peer ID and let the pruned peer find them in the DHT -- we can't trust\n                // unsigned address records through PX anyways\n                // Finding signed records in the DHT is not supported at the time of writing in js-libp2p\n                const peerId = peer_id_1.default.createFromB58String(p);\n                px.push({\n                    peerID: peerId.toBytes(),\n                    signedPeerRecord: this._libp2p.peerStore.addressBook.getRawEnvelope(peerId),\n                });\n            });\n        }\n        return {\n            topicID: topic,\n            peers: px,\n            backoff: backoff,\n        };\n    }\n}\nexports.WakuRelay = WakuRelay;\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.RelayMaxIHaveLength = exports.RelayOpportunisticGraftPeers = exports.RelayOpportunisticGraftTicks = exports.RelayFanoutTTL = exports.RelayPruneBackoff = exports.RelayPrunePeers = exports.RelayHeartbeatInterval = exports.RelayHeartbeatInitialDelay = exports.RelayGossipFactor = exports.RelayPingContentTopic = exports.RelayCodecs = exports.minute = exports.second = void 0;\nexports.second = 1000;\nexports.minute = 60 * exports.second;\n/**\n * RelayCodec is the libp2p identifier for the waku relay protocol\n */\nexports.RelayCodecs = [\n    '/vac/waku/relay/2.0.0-beta2',\n    '/vac/waku/relay/2.0.0',\n];\nexports.RelayPingContentTopic = '/relay-ping/1/ping/null';\n/**\n * RelayGossipFactor affects how many peers we will emit gossip to at each heartbeat.\n * We will send gossip to RelayGossipFactor * (total number of non-mesh peers), or\n * RelayDlazy, whichever is greater.\n */\nexports.RelayGossipFactor = 0.25;\n/**\n * GossipsubHeartbeatInitialDelay is the short delay before the heartbeat timer begins\n * after the router is initialized.\n */\nexports.RelayHeartbeatInitialDelay = 100;\n/**\n * RelayHeartbeatInterval controls the time between heartbeats.\n */\nexports.RelayHeartbeatInterval = exports.second;\n/**\n * RelayPrunePeers controls the number of peers to include in prune Peer eXchange.\n * When we prune a peer that's eligible for PX (has a good score, etc), we will try to\n * send them signed peer records for up to RelayPrunePeers other peers that we\n * know of.\n */\nexports.RelayPrunePeers = 16;\n/**\n * RelayPruneBackoff controls the backoff time for pruned peers. This is how long\n * a peer must wait before attempting to graft into our mesh again after being pruned.\n * When pruning a peer, we send them our value of RelayPruneBackoff so they know\n * the minimum time to wait. Peers running older versions may not send a backoff time,\n * so if we receive a prune message without one, we will wait at least RelayPruneBackoff\n * before attempting to re-graft.\n */\nexports.RelayPruneBackoff = exports.minute;\n/**\n * RelayFanoutTTL controls how long we keep track of the fanout state. If it's been\n * RelayFanoutTTL since we've published to a topic that we're not subscribed to,\n * we'll delete the fanout map for that topic.\n */\nexports.RelayFanoutTTL = exports.minute;\n/**\n * RelayOpportunisticGraftTicks is the number of heartbeat ticks for attempting to improve the mesh\n * with opportunistic grafting. Every RelayOpportunisticGraftTicks we will attempt to select some\n * high-scoring mesh peers to replace lower-scoring ones, if the median score of our mesh peers falls\n * below a threshold\n */\nexports.RelayOpportunisticGraftTicks = 60;\n/**\n * RelayOpportunisticGraftPeers is the number of peers to opportunistically graft.\n */\nexports.RelayOpportunisticGraftPeers = 2;\n/**\n * RelayMaxIHaveLength is the maximum number of messages to include in an IHAVE message.\n * Also controls the maximum number of IHAVE ids we will accept and request with IWANT from a\n * peer within a heartbeat, to protect from IHAVE floods. You should adjust this value from the\n * default if your system is pushing more than 5000 messages in GossipsubHistoryGossip heartbeats;\n * with the defaults this is 1666 messages/s.\n */\nexports.RelayMaxIHaveLength = 5000;\n//# sourceMappingURL=constants.js.map","import '@ethersproject/shims';\n\nimport { PublicKeyMessage } from './messaging/wire';\nimport { hexToBuf, equalByteArrays, bufToHex } from 'js-waku/lib/utils';\nimport * as sigUtil from 'eth-sig-util';\n\n/**\n * Sign the encryption public key with Web3. This can then be published to let other\n * users know to use this encryption public key to encrypt messages for the\n * Ethereum Address holder.\n */\nexport async function createPublicKeyMessage(\n  address: string,\n  encryptionPublicKey: Uint8Array,\n  providerRequest: (request: {\n    method: string;\n    params?: Array<any>;\n  }) => Promise<any>\n): Promise<PublicKeyMessage> {\n  const signature = await signEncryptionKey(\n    encryptionPublicKey,\n    address,\n    providerRequest\n  );\n\n  console.log('Asking wallet to sign Public Key Message');\n  console.log('Public Key Message signed');\n\n  return new PublicKeyMessage({\n    encryptionPublicKey: encryptionPublicKey,\n    ethAddress: hexToBuf(address),\n    signature: hexToBuf(signature),\n  });\n}\n\nfunction buildMsgParams(encryptionPublicKey: Uint8Array, fromAddress: string) {\n  return JSON.stringify({\n    domain: {\n      chainId: 1,\n      name: 'Ethereum Private Message over Waku',\n      version: '1',\n    },\n    message: {\n      encryptionPublicKey: bufToHex(encryptionPublicKey),\n      ownerAddress: fromAddress,\n    },\n    // Refers to the keys of the *types* object below.\n    primaryType: 'PublishEncryptionPublicKey',\n    types: {\n      EIP712Domain: [\n        { name: 'name', type: 'string' },\n        { name: 'version', type: 'string' },\n        { name: 'chainId', type: 'uint256' },\n      ],\n      PublishEncryptionPublicKey: [\n        { name: 'encryptionPublicKey', type: 'string' },\n        { name: 'ownerAddress', type: 'string' },\n      ],\n    },\n  });\n}\n\nexport async function signEncryptionKey(\n  encryptionPublicKey: Uint8Array,\n  fromAddress: string,\n  providerRequest: (request: {\n    method: string;\n    params?: Array<any>;\n    from?: string;\n  }) => Promise<any>\n): Promise<Uint8Array> {\n  const msgParams = buildMsgParams(encryptionPublicKey, fromAddress);\n\n  const result = await providerRequest({\n    method: 'eth_signTypedData_v3',\n    params: [fromAddress, msgParams],\n    from: fromAddress,\n  });\n\n  console.log('TYPED SIGNED:' + JSON.stringify(result));\n\n  return hexToBuf(result);\n}\n\n/**\n * Validate that the Encryption Public Key was signed by the holder of the given Ethereum address.\n */\nexport function validatePublicKeyMessage(msg: PublicKeyMessage): boolean {\n  const recovered = sigUtil.recoverTypedSignature_v4({\n    data: JSON.parse(\n      buildMsgParams(msg.encryptionPublicKey, '0x' + bufToHex(msg.ethAddress))\n    ),\n    sig: '0x' + bufToHex(msg.signature),\n  });\n\n  console.log('Recovered', recovered);\n  console.log('ethAddress', '0x' + bufToHex(msg.ethAddress));\n\n  return equalByteArrays(recovered, msg.ethAddress);\n}\n","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.v4 = void 0;\nconst v4Crypto = __importStar(require(\"./v4\"));\nexports.v4 = v4Crypto;\n__exportStar(require(\"./constants\"), exports);\n__exportStar(require(\"./enr\"), exports);\n__exportStar(require(\"./types\"), exports);\n__exportStar(require(\"./create\"), exports);\n__exportStar(require(\"./keypair\"), exports);\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.AbstractKeypair = exports.KeypairType = void 0;\nvar KeypairType;\n(function (KeypairType) {\n    KeypairType[KeypairType[\"rsa\"] = 0] = \"rsa\";\n    KeypairType[KeypairType[\"ed25519\"] = 1] = \"ed25519\";\n    KeypairType[KeypairType[\"secp256k1\"] = 2] = \"secp256k1\";\n})(KeypairType = exports.KeypairType || (exports.KeypairType = {}));\nclass AbstractKeypair {\n    constructor(privateKey, publicKey) {\n        if ((this._privateKey = privateKey) && !this.privateKeyVerify()) {\n            throw new Error('Invalid private key');\n        }\n        if ((this._publicKey = publicKey) && !this.publicKeyVerify()) {\n            throw new Error('Invalid private key');\n        }\n    }\n    get privateKey() {\n        if (!this._privateKey) {\n            throw new Error();\n        }\n        return this._privateKey;\n    }\n    get publicKey() {\n        if (!this._publicKey) {\n            throw new Error();\n        }\n        return this._publicKey;\n    }\n    privateKeyVerify() {\n        return true;\n    }\n    publicKeyVerify() {\n        return true;\n    }\n    hasPrivateKey() {\n        return Boolean(this._privateKey);\n    }\n}\nexports.AbstractKeypair = AbstractKeypair;\n//# sourceMappingURL=types.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getPeersForProtocol = exports.selectRandomPeer = void 0;\n/**\n * Returns a pseudo-random peer that supports the given protocol.\n * Useful for protocols such as store and light push\n */\nfunction selectRandomPeer(peers) {\n    if (peers.length === 0)\n        return;\n    const index = Math.round(Math.random() * (peers.length - 1));\n    return peers[index];\n}\nexports.selectRandomPeer = selectRandomPeer;\n/**\n * Returns the list of peers that supports the given protocol.\n */\nfunction getPeersForProtocol(libp2p, protocol) {\n    return Array.from(libp2p.peerStore.peers.values()).filter((peer) => peer.protocols.includes(protocol));\n}\nexports.getPeersForProtocol = getPeersForProtocol;\n//# sourceMappingURL=select_peer.js.map","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.WakuLightPush = exports.PushResponse = exports.LightPushCodec = void 0;\nconst it_concat_1 = __importDefault(require(\"it-concat\"));\nconst it_length_prefixed_1 = __importDefault(require(\"it-length-prefixed\"));\nconst it_pipe_1 = __importDefault(require(\"it-pipe\"));\nconst light_push_1 = require(\"../../proto/waku/v2/light_push\");\nObject.defineProperty(exports, \"PushResponse\", { enumerable: true, get: function () { return light_push_1.PushResponse; } });\nconst select_peer_1 = require(\"../select_peer\");\nconst waku_1 = require(\"../waku\");\nconst push_rpc_1 = require(\"./push_rpc\");\nexports.LightPushCodec = '/vac/waku/lightpush/2.0.0-beta1';\n/**\n * Implements the [Waku v2 Light Push protocol](https://rfc.vac.dev/spec/19/).\n */\nclass WakuLightPush {\n    constructor(libp2p, options) {\n        this.libp2p = libp2p;\n        if (options?.pubSubTopic) {\n            this.pubSubTopic = options.pubSubTopic;\n        }\n        else {\n            this.pubSubTopic = waku_1.DefaultPubSubTopic;\n        }\n    }\n    async push(message, opts) {\n        let peer;\n        if (opts?.peerId) {\n            peer = this.libp2p.peerStore.get(opts.peerId);\n            if (!peer)\n                throw 'Peer is unknown';\n        }\n        else {\n            peer = this.randomPeer;\n        }\n        if (!peer)\n            throw 'No peer available';\n        if (!peer.protocols.includes(exports.LightPushCodec))\n            throw 'Peer does not register waku light push protocol';\n        const connection = this.libp2p.connectionManager.get(peer.id);\n        if (!connection)\n            throw 'Failed to get a connection to the peer';\n        const { stream } = await connection.newStream(exports.LightPushCodec);\n        try {\n            const pubSubTopic = opts?.pubSubTopic\n                ? opts.pubSubTopic\n                : this.pubSubTopic;\n            const query = push_rpc_1.PushRPC.createRequest(message, pubSubTopic);\n            const res = await it_pipe_1.default([query.encode()], it_length_prefixed_1.default.encode(), stream, it_length_prefixed_1.default.decode(), it_concat_1.default);\n            try {\n                const response = push_rpc_1.PushRPC.decode(res.slice()).response;\n                if (!response) {\n                    console.log('No response in PushRPC');\n                    return null;\n                }\n                return response;\n            }\n            catch (err) {\n                console.log('Failed to decode push reply', err);\n            }\n        }\n        catch (err) {\n            console.log('Failed to send waku light push request', err);\n        }\n        return null;\n    }\n    /**\n     * Returns known peers from the address book (`libp2p.peerStore`) that support\n     * light push protocol. Waku may or  may not be currently connected to these peers.\n     */\n    get peers() {\n        return select_peer_1.getPeersForProtocol(this.libp2p, exports.LightPushCodec);\n    }\n    /**\n     * Returns a random peer that supports light push protocol from the address\n     * book (`libp2p.peerStore`). Waku may or  may not be currently connected to\n     * this peer.\n     */\n    get randomPeer() {\n        return select_peer_1.selectRandomPeer(this.peers);\n    }\n}\nexports.WakuLightPush = WakuLightPush;\n//# sourceMappingURL=index.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.symmetric = exports.TagSize = exports.IvSize = exports.SymmetricKeySize = void 0;\nexports.SymmetricKeySize = 32;\nexports.IvSize = 12;\nexports.TagSize = 16;\nexports.symmetric = {};\nPromise.resolve().then(() => __importStar(require('./browser'))).then((mod) => {\n    exports.symmetric = mod;\n})\n    .catch((eBrowser) => {\n    Promise.resolve().then(() => __importStar(require('./node'))).then((mod) => {\n        exports.symmetric = mod;\n    })\n        .catch((eNode) => {\n        throw `Could not load any symmetric crypto modules: ${eBrowser}, ${eNode}`;\n    });\n});\n//# sourceMappingURL=index.js.map","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.WakuStore = exports.PageDirection = exports.DefaultPageSize = exports.StoreCodec = void 0;\nconst debug_1 = __importDefault(require(\"debug\"));\nconst it_concat_1 = __importDefault(require(\"it-concat\"));\nconst it_length_prefixed_1 = __importDefault(require(\"it-length-prefixed\"));\nconst it_pipe_1 = __importDefault(require(\"it-pipe\"));\nconst proto_1 = require(\"../../proto\");\nconst select_peer_1 = require(\"../select_peer\");\nconst utils_1 = require(\"../utils\");\nconst waku_1 = require(\"../waku\");\nconst waku_message_1 = require(\"../waku_message\");\nconst history_rpc_1 = require(\"./history_rpc\");\nObject.defineProperty(exports, \"PageDirection\", { enumerable: true, get: function () { return history_rpc_1.PageDirection; } });\nconst dbg = debug_1.default('waku:store');\nexports.StoreCodec = '/vac/waku/store/2.0.0-beta3';\nexports.DefaultPageSize = 10;\n/**\n * Implements the [Waku v2 Store protocol](https://rfc.vac.dev/spec/13/).\n */\nclass WakuStore {\n    constructor(libp2p, options) {\n        this.libp2p = libp2p;\n        if (options?.pubSubTopic) {\n            this.pubSubTopic = options.pubSubTopic;\n        }\n        else {\n            this.pubSubTopic = waku_1.DefaultPubSubTopic;\n        }\n        this.decryptionKeys = new Map();\n    }\n    /**\n     * Do a History Query to a Waku Store.\n     *\n     * @param contentTopics The content topics to pass to the query, leave empty to\n     * retrieve all messages.\n     *\n     * @throws If not able to reach a Waku Store peer to query\n     * or if an error is encountered when processing the reply.\n     */\n    async queryHistory(contentTopics, options) {\n        let startTime, endTime;\n        if (options?.timeFilter) {\n            startTime = options.timeFilter.startTime.getTime() / 1000;\n            endTime = options.timeFilter.endTime.getTime() / 1000;\n        }\n        const opts = Object.assign({\n            pubSubTopic: this.pubSubTopic,\n            pageDirection: history_rpc_1.PageDirection.BACKWARD,\n            pageSize: exports.DefaultPageSize,\n        }, options, {\n            startTime,\n            endTime,\n        }, { contentTopics });\n        dbg('Querying history with the following options', options);\n        let peer;\n        if (opts.peerId) {\n            peer = this.libp2p.peerStore.get(opts.peerId);\n            if (!peer)\n                throw `Failed to retrieve connection details for provided peer in peer store: ${opts.peerId.toB58String()}`;\n        }\n        else {\n            peer = this.randomPeer;\n            if (!peer)\n                throw 'Failed to find known peer that registers waku store protocol';\n        }\n        if (!peer.protocols.includes(exports.StoreCodec))\n            throw `Peer does not register waku store protocol: ${peer.id.toB58String()}`;\n        const connection = this.libp2p.connectionManager.get(peer.id);\n        if (!connection)\n            throw 'Failed to get a connection to the peer';\n        const decryptionKeys = Array.from(this.decryptionKeys).map(([key, { method, contentTopics }]) => {\n            return {\n                key,\n                method,\n                contentTopics,\n            };\n        });\n        // Add the decryption keys passed to this function against the\n        // content topics also passed to this function.\n        if (opts.decryptionKeys) {\n            opts.decryptionKeys.forEach((key) => {\n                decryptionKeys.push({\n                    key: utils_1.hexToBuf(key),\n                    contentTopics: contentTopics.length ? contentTopics : undefined,\n                    method: undefined,\n                });\n            });\n        }\n        const messages = [];\n        let cursor = undefined;\n        while (true) {\n            const { stream } = await connection.newStream(exports.StoreCodec);\n            const queryOpts = Object.assign(opts, { cursor });\n            const historyRpcQuery = history_rpc_1.HistoryRPC.createQuery(queryOpts);\n            dbg('Querying store peer', connection.remoteAddr.toString());\n            const res = await it_pipe_1.default([historyRpcQuery.encode()], it_length_prefixed_1.default.encode(), stream, it_length_prefixed_1.default.decode(), it_concat_1.default);\n            const reply = history_rpc_1.HistoryRPC.decode(res.slice());\n            const response = reply.response;\n            if (!response) {\n                throw 'History response misses response field';\n            }\n            if (response.error &&\n                response.error === proto_1.HistoryResponse_Error.ERROR_INVALID_CURSOR) {\n                throw 'History response contains an Error: INVALID CURSOR';\n            }\n            if (!response.messages || !response.messages.length) {\n                // No messages left (or stored)\n                console.log('No messages present in HistoryRPC response');\n                return messages;\n            }\n            dbg(`${response.messages.length} messages retrieved for pubsub topic ${opts.pubSubTopic}`);\n            const pageMessages = [];\n            await Promise.all(response.messages.map(async (protoMsg) => {\n                const msg = await waku_message_1.WakuMessage.decodeProto(protoMsg, decryptionKeys);\n                if (msg) {\n                    messages.push(msg);\n                    pageMessages.push(msg);\n                }\n            }));\n            let abort = false;\n            if (opts.callback) {\n                abort = Boolean(opts.callback(pageMessages));\n            }\n            const responsePageSize = response.pagingInfo?.pageSize;\n            const queryPageSize = historyRpcQuery.query?.pagingInfo?.pageSize;\n            if (abort ||\n                // Response page size smaller than query, meaning this is the last page\n                (responsePageSize && queryPageSize && responsePageSize < queryPageSize)) {\n                return messages;\n            }\n            cursor = response.pagingInfo?.cursor;\n            if (cursor === undefined) {\n                // If the server does not return cursor then there is an issue,\n                // Need to abort or we end up in an infinite loop\n                console.log('No cursor returned by peer.');\n                return messages;\n            }\n        }\n    }\n    /**\n     * Register a decryption key to attempt decryption of messages received in any\n     * subsequent [[queryHistory]] call. This can either be a private key for\n     * asymmetric encryption or a symmetric key. [[WakuStore]] will attempt to\n     * decrypt messages using both methods.\n     *\n     * Strings must be in hex format.\n     */\n    addDecryptionKey(key, options) {\n        this.decryptionKeys.set(utils_1.hexToBuf(key), options ?? {});\n    }\n    /**\n     * Delete a decryption key that was used to attempt decryption of messages\n     * received in subsequent [[queryHistory]] calls.\n     *\n     * Strings must be in hex format.\n     */\n    deleteDecryptionKey(key) {\n        this.decryptionKeys.delete(utils_1.hexToBuf(key));\n    }\n    /**\n     * Returns known peers from the address book (`libp2p.peerStore`) that support\n     * store protocol. Waku may or  may not be currently connected to these peers.\n     */\n    get peers() {\n        return select_peer_1.getPeersForProtocol(this.libp2p, exports.StoreCodec);\n    }\n    /**\n     * Returns a random peer that supports store protocol from the address\n     * book (`libp2p.peerStore`). Waku may or  may not be currently connected to\n     * this peer.\n     */\n    get randomPeer() {\n        return select_peer_1.selectRandomPeer(this.peers);\n    }\n}\nexports.WakuStore = WakuStore;\n//# sourceMappingURL=index.js.map","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DnsNodeDiscovery = void 0;\nconst assert_1 = __importDefault(require(\"assert\"));\nconst debug_1 = require(\"debug\");\nconst enr_1 = require(\"../enr\");\nconst dns_over_https_1 = require(\"./dns_over_https\");\nconst enrtree_1 = require(\"./enrtree\");\nconst dbg = debug_1.debug('waku:discovery:dns');\nclass DnsNodeDiscovery {\n    constructor(dns) {\n        this._errorTolerance = 10;\n        this._DNSTreeCache = {};\n        this.dns = dns;\n    }\n    static dnsOverHttp(endpoints) {\n        const dnsClient = new dns_over_https_1.DnsOverHttps(endpoints);\n        return new DnsNodeDiscovery(dnsClient);\n    }\n    /**\n     * Returns a list of verified peers listed in an EIP-1459 DNS tree. Method may\n     * return fewer peers than requested if `maxQuantity` is larger than the number\n     * of ENR records or the number of errors/duplicate peers encountered by randomized\n     * search exceeds `maxQuantity` plus the `errorTolerance` factor.\n     */\n    async getPeers(maxQuantity, enrTreeUrls) {\n        let totalSearches = 0;\n        const peers = [];\n        const networkIndex = Math.floor(Math.random() * enrTreeUrls.length);\n        const { publicKey, domain } = enrtree_1.ENRTree.parseTree(enrTreeUrls[networkIndex]);\n        while (peers.length < maxQuantity &&\n            totalSearches < maxQuantity + this._errorTolerance) {\n            const context = {\n                domain,\n                publicKey,\n                visits: {},\n            };\n            const peer = await this._search(domain, context);\n            if (peer && isNewPeer(peer, peers)) {\n                peers.push(peer);\n                dbg(`got new peer candidate from DNS address=${peer.nodeId}@${peer.ip}`);\n            }\n            totalSearches++;\n        }\n        return peers;\n    }\n    /**\n     * Runs a recursive, randomized descent of the DNS tree to retrieve a single\n     * ENR record as an ENR. Returns null if parsing or DNS resolution fails.\n     */\n    async _search(subdomain, context) {\n        const entry = await this._getTXTRecord(subdomain, context);\n        context.visits[subdomain] = true;\n        let next;\n        let branches;\n        const entryType = getEntryType(entry);\n        try {\n            switch (entryType) {\n                case enrtree_1.ENRTree.ROOT_PREFIX:\n                    next = enrtree_1.ENRTree.parseAndVerifyRoot(entry, context.publicKey);\n                    return await this._search(next, context);\n                case enrtree_1.ENRTree.BRANCH_PREFIX:\n                    branches = enrtree_1.ENRTree.parseBranch(entry);\n                    next = selectRandomPath(branches, context);\n                    return await this._search(next, context);\n                case enrtree_1.ENRTree.RECORD_PREFIX:\n                    return enr_1.ENR.decodeTxt(entry);\n                default:\n                    return null;\n            }\n        }\n        catch (error) {\n            dbg(`Failed to search DNS tree ${entryType} at subdomain ${subdomain}: ${error}`);\n            return null;\n        }\n    }\n    /**\n     * Retrieves the TXT record stored at a location from either\n     * this DNS tree cache or via DNS query\n     */\n    async _getTXTRecord(subdomain, context) {\n        if (this._DNSTreeCache[subdomain]) {\n            return this._DNSTreeCache[subdomain];\n        }\n        // Location is either the top level tree entry host or a subdomain of it.\n        const location = subdomain !== context.domain\n            ? `${subdomain}.${context.domain}`\n            : context.domain;\n        const response = await this.dns.resolveTXT(location);\n        assert_1.default(response.length, 'Received empty result array while fetching TXT record');\n        assert_1.default(response[0].length, 'Received empty TXT record');\n        // Branch entries can be an array of strings of comma delimited subdomains, with\n        // some subdomain strings split across the array elements\n        const result = response.join('');\n        this._DNSTreeCache[subdomain] = result;\n        return result;\n    }\n}\nexports.DnsNodeDiscovery = DnsNodeDiscovery;\nfunction getEntryType(entry) {\n    if (entry.startsWith(enrtree_1.ENRTree.ROOT_PREFIX))\n        return enrtree_1.ENRTree.ROOT_PREFIX;\n    if (entry.startsWith(enrtree_1.ENRTree.BRANCH_PREFIX))\n        return enrtree_1.ENRTree.BRANCH_PREFIX;\n    if (entry.startsWith(enrtree_1.ENRTree.RECORD_PREFIX))\n        return enrtree_1.ENRTree.RECORD_PREFIX;\n    return '';\n}\n/**\n * Returns a randomly selected subdomain string from the list provided by a branch\n * entry record.\n *\n * The client must track subdomains which are already resolved to avoid\n * going into an infinite loop b/c branch entries can contain\n * circular references. It’s in the client’s best interest to traverse the\n * tree in random order.\n */\nfunction selectRandomPath(branches, context) {\n    // Identify domains already visited in this traversal of the DNS tree.\n    // Then filter against them to prevent cycles.\n    const circularRefs = {};\n    for (const [idx, subdomain] of branches.entries()) {\n        if (context.visits[subdomain]) {\n            circularRefs[idx] = true;\n        }\n    }\n    // If all possible paths are circular...\n    if (Object.keys(circularRefs).length === branches.length) {\n        throw new Error('Unresolvable circular path detected');\n    }\n    // Randomly select a viable path\n    let index;\n    do {\n        index = Math.floor(Math.random() * branches.length);\n    } while (circularRefs[index]);\n    return branches[index];\n}\n/**\n * @returns false if candidate peer already exists in the\n *         current collection of peers based on the node id value;\n *         true otherwise.\n */\nfunction isNewPeer(peer, peers) {\n    if (!peer || !peer.nodeId)\n        return false;\n    for (const existingPeer of peers) {\n        if (peer.nodeId === existingPeer.nodeId) {\n            return false;\n        }\n    }\n    return true;\n}\n//# sourceMappingURL=dns.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ENRKeyPair = exports.nodeId = exports.verify = exports.sign = exports.publicKey = exports.createPrivateKey = exports.hash = void 0;\nconst crypto_1 = __importDefault(require(\"crypto\"));\nconst js_sha3_1 = require(\"js-sha3\");\nconst secp256k1 = __importStar(require(\"secp256k1\"));\nconst create_1 = require(\"./create\");\nfunction hash(input) {\n    return Buffer.from(js_sha3_1.keccak256.arrayBuffer(input));\n}\nexports.hash = hash;\nasync function createPrivateKey() {\n    return Buffer.from(await randomBytes(32));\n}\nexports.createPrivateKey = createPrivateKey;\nfunction publicKey(privKey) {\n    return Buffer.from(secp256k1.publicKeyCreate(privKey));\n}\nexports.publicKey = publicKey;\nfunction sign(privKey, msg) {\n    const { signature } = secp256k1.ecdsaSign(hash(msg), privKey);\n    return Buffer.from(signature);\n}\nexports.sign = sign;\nfunction verify(pubKey, msg, sig) {\n    // Remove the recovery id if present (byte #65)\n    return secp256k1.ecdsaVerify(sig.slice(0, 64), hash(msg), pubKey);\n}\nexports.verify = verify;\nfunction nodeId(pubKey) {\n    const uncompressedPubkey = secp256k1.publicKeyConvert(pubKey, false);\n    return create_1.createNodeId(hash(uncompressedPubkey.slice(1)));\n}\nexports.nodeId = nodeId;\nclass ENRKeyPair {\n    constructor(nodeId, privateKey, publicKey) {\n        this.nodeId = nodeId;\n        this.privateKey = privateKey;\n        this.publicKey = publicKey;\n    }\n    static async create(privateKey) {\n        if (privateKey) {\n            if (!secp256k1.privateKeyVerify(privateKey)) {\n                throw new Error('Invalid private key');\n            }\n        }\n        const _privateKey = privateKey || (await createPrivateKey());\n        const _publicKey = publicKey(_privateKey);\n        const _nodeId = nodeId(_publicKey);\n        return new ENRKeyPair(_nodeId, _privateKey, _publicKey);\n    }\n    sign(msg) {\n        return sign(this.privateKey, msg);\n    }\n    verify(msg, sig) {\n        return verify(this.publicKey, msg, sig);\n    }\n}\nexports.ENRKeyPair = ENRKeyPair;\nfunction randomBytes(length) {\n    if (typeof window !== 'undefined' && window && window.crypto) {\n        const array = new Uint8Array(length);\n        window.crypto.getRandomValues(array);\n        return array;\n    }\n    else {\n        return crypto_1.default.randomBytes(length);\n    }\n}\n//# sourceMappingURL=v4.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.createNodeId = void 0;\nconst utils_1 = require(\"../utils\");\nfunction createNodeId(buffer) {\n    if (buffer.length !== 32) {\n        throw new Error('NodeId must be 32 bytes in length');\n    }\n    return utils_1.bufToHex(buffer);\n}\nexports.createNodeId = createNodeId;\n//# sourceMappingURL=create.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MULTIADDR_LENGTH_SIZE = exports.ERR_NO_SIGNATURE = exports.ERR_INVALID_ID = exports.MAX_RECORD_SIZE = void 0;\n// Maximum encoded size of an ENR\nexports.MAX_RECORD_SIZE = 300;\nexports.ERR_INVALID_ID = 'Invalid record id';\nexports.ERR_NO_SIGNATURE = 'No valid signature found';\n// The maximum length of byte size of a multiaddr to encode in the `multiaddr` field\n// The size is a big endian 16-bit unsigned integer\nexports.MULTIADDR_LENGTH_SIZE = 2;\n//# sourceMappingURL=constants.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.createKeypairFromPeerId = exports.createPeerIdFromKeypair = exports.createKeypair = exports.generateKeypair = void 0;\nconst libp2p_crypto_1 = require(\"libp2p-crypto\");\nconst multihashes_1 = __importDefault(require(\"multihashes\"));\nconst peer_id_1 = __importDefault(require(\"peer-id\"));\nconst { keysPBM, supportedKeys } = libp2p_crypto_1.keys;\nconst constants_1 = require(\"./constants\");\nconst secp256k1_1 = require(\"./secp256k1\");\nconst types_1 = require(\"./types\");\n__exportStar(require(\"./types\"), exports);\n__exportStar(require(\"./secp256k1\"), exports);\nasync function generateKeypair(type) {\n    switch (type) {\n        case types_1.KeypairType.secp256k1:\n            return await secp256k1_1.Secp256k1Keypair.generate();\n        default:\n            throw new Error(constants_1.ERR_TYPE_NOT_IMPLEMENTED);\n    }\n}\nexports.generateKeypair = generateKeypair;\nfunction createKeypair(type, privateKey, publicKey) {\n    switch (type) {\n        case types_1.KeypairType.secp256k1:\n            return new secp256k1_1.Secp256k1Keypair(privateKey, publicKey);\n        default:\n            throw new Error(constants_1.ERR_TYPE_NOT_IMPLEMENTED);\n    }\n}\nexports.createKeypair = createKeypair;\nfunction createPeerIdFromKeypair(keypair) {\n    switch (keypair.type) {\n        case types_1.KeypairType.secp256k1: {\n            // manually create a peer id to avoid expensive ops\n            const privKey = keypair.hasPrivateKey()\n                ? new supportedKeys.secp256k1.Secp256k1PrivateKey(keypair.privateKey, keypair.publicKey)\n                : undefined;\n            const pubKey = new supportedKeys.secp256k1.Secp256k1PublicKey(keypair.publicKey);\n            const id = multihashes_1.default.encode(pubKey.bytes, 'identity');\n            return new peer_id_1.default(id, privKey, pubKey);\n        }\n        default:\n            throw new Error(constants_1.ERR_TYPE_NOT_IMPLEMENTED);\n    }\n}\nexports.createPeerIdFromKeypair = createPeerIdFromKeypair;\nfunction createKeypairFromPeerId(peerId) {\n    // pub/private key bytes from peer-id are encoded in protobuf format\n    const pub = keysPBM.PublicKey.decode(peerId.pubKey.bytes);\n    return createKeypair(pub.Type, peerId.privKey ? Buffer.from(peerId.privKey.marshal()) : undefined, Buffer.from(pub.Data));\n}\nexports.createKeypairFromPeerId = createKeypairFromPeerId;\n//# sourceMappingURL=index.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Secp256k1Keypair = exports.secp256k1PublicKeyToRaw = exports.secp256k1PublicKeyToFull = exports.secp256k1PublicKeyToCompressed = void 0;\nconst buffer_1 = require(\"buffer\");\nconst crypto_1 = __importDefault(require(\"crypto\"));\nconst secp256k1 = __importStar(require(\"secp256k1\"));\nconst types_1 = require(\"./types\");\nfunction secp256k1PublicKeyToCompressed(publicKey) {\n    if (publicKey.length === 64) {\n        publicKey = buffer_1.Buffer.concat([buffer_1.Buffer.from([4]), publicKey]);\n    }\n    return buffer_1.Buffer.from(secp256k1.publicKeyConvert(publicKey, true));\n}\nexports.secp256k1PublicKeyToCompressed = secp256k1PublicKeyToCompressed;\nfunction secp256k1PublicKeyToFull(publicKey) {\n    if (publicKey.length === 64) {\n        return buffer_1.Buffer.concat([buffer_1.Buffer.from([4]), publicKey]);\n    }\n    return buffer_1.Buffer.from(secp256k1.publicKeyConvert(publicKey, false));\n}\nexports.secp256k1PublicKeyToFull = secp256k1PublicKeyToFull;\nfunction secp256k1PublicKeyToRaw(publicKey) {\n    return buffer_1.Buffer.from(secp256k1.publicKeyConvert(publicKey, false).slice(1));\n}\nexports.secp256k1PublicKeyToRaw = secp256k1PublicKeyToRaw;\nconst Secp256k1Keypair = class Secp256k1Keypair extends types_1.AbstractKeypair {\n    constructor(privateKey, publicKey) {\n        let pub = publicKey;\n        if (pub) {\n            pub = secp256k1PublicKeyToCompressed(pub);\n        }\n        super(privateKey, pub);\n        this.type = types_1.KeypairType.secp256k1;\n    }\n    static async generate() {\n        const privateKey = buffer_1.Buffer.from(await randomBytes(32));\n        const publicKey = secp256k1.publicKeyCreate(privateKey);\n        return new Secp256k1Keypair(privateKey, buffer_1.Buffer.from(publicKey));\n    }\n    privateKeyVerify(key = this._privateKey) {\n        if (key) {\n            return secp256k1.privateKeyVerify(key);\n        }\n        return true;\n    }\n    publicKeyVerify(key = this._publicKey) {\n        if (key) {\n            return secp256k1.publicKeyVerify(key);\n        }\n        return true;\n    }\n    sign(msg) {\n        const { signature, recid } = secp256k1.ecdsaSign(msg, this.privateKey);\n        return buffer_1.Buffer.concat([signature, buffer_1.Buffer.from([recid])]);\n    }\n    verify(msg, sig) {\n        return secp256k1.ecdsaVerify(sig, msg, this.publicKey);\n    }\n};\nexports.Secp256k1Keypair = Secp256k1Keypair;\nfunction randomBytes(length) {\n    if (typeof window !== 'undefined' && window && window.crypto) {\n        const array = new Uint8Array(length);\n        window.crypto.getRandomValues(array);\n        return array;\n    }\n    else {\n        return crypto_1.default.randomBytes(length);\n    }\n}\n//# sourceMappingURL=secp256k1.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DnsOverHttps = void 0;\nconst dns_query_1 = require(\"dns-query\");\nconst { cloudflare, google, opendns } = dns_query_1.endpoints;\nclass DnsOverHttps {\n    /**\n     * Create new Dns-Over-Http DNS client.\n     *\n     * @param endpoints The endpoints for Dns-Over-Https queries.\n     * See [dns-query](https://www.npmjs.com/package/dns-query) for details.\n     * Defaults to cloudflare, google and opendns.\n     *\n     * @throws {code: string} If DNS query fails.\n     */\n    constructor(endpoints = [cloudflare, google, opendns]) {\n        this.endpoints = endpoints;\n    }\n    async resolveTXT(domain) {\n        const response = await dns_query_1.query({\n            questions: [{ type: 'TXT', name: domain }],\n        });\n        const answers = response.answers;\n        const data = answers.map((a) => a.data);\n        const result = [];\n        data.forEach((d) => {\n            if (typeof d === 'string') {\n                result.push(d);\n            }\n            else if (Array.isArray(d)) {\n                d.forEach((sd) => {\n                    if (typeof sd === 'string') {\n                        result.push(sd);\n                    }\n                    else {\n                        result.push(Buffer.from(sd).toString('utf-8'));\n                    }\n                });\n            }\n            else {\n                result.push(Buffer.from(d).toString('utf-8'));\n            }\n        });\n        return result;\n    }\n}\nexports.DnsOverHttps = DnsOverHttps;\n//# sourceMappingURL=dns_over_https.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ENRTree = void 0;\nconst assert_1 = __importDefault(require(\"assert\"));\nconst base64url_1 = __importDefault(require(\"base64url\"));\nconst base32 = __importStar(require(\"hi-base32\"));\nconst secp256k1_1 = require(\"secp256k1\");\nconst enr_1 = require(\"../enr\");\nconst utils_1 = require(\"../utils\");\nclass ENRTree {\n    /**\n     * Extracts the branch subdomain referenced by a DNS tree root string after verifying\n     * the root record signature with its base32 compressed public key.\n     */\n    static parseAndVerifyRoot(root, publicKey) {\n        assert_1.default(root.startsWith(this.ROOT_PREFIX), `ENRTree root entry must start with '${this.ROOT_PREFIX}'`);\n        const rootValues = ENRTree.parseRootValues(root);\n        const decodedPublicKey = base32.decode.asBytes(publicKey);\n        // The signature is a 65-byte secp256k1 over the keccak256 hash\n        // of the record content, excluding the `sig=` part, encoded as URL-safe base64 string\n        // (Trailing recovery bit must be trimmed to pass `ecdsaVerify` method)\n        const signedComponent = root.split(' sig')[0];\n        const signedComponentBuffer = Buffer.from(signedComponent);\n        const signatureBuffer = base64url_1.default\n            .toBuffer(rootValues.signature)\n            .slice(0, 64);\n        const keyBuffer = Buffer.from(decodedPublicKey);\n        const isVerified = secp256k1_1.ecdsaVerify(signatureBuffer, utils_1.keccak256Buf(signedComponentBuffer), keyBuffer);\n        assert_1.default(isVerified, 'Unable to verify ENRTree root signature');\n        return rootValues.eRoot;\n    }\n    static parseRootValues(txt) {\n        const matches = txt.match(/^enrtree-root:v1 e=([^ ]+) l=([^ ]+) seq=(\\d+) sig=([^ ]+)$/);\n        assert_1.default.ok(Array.isArray(matches), 'Could not parse ENRTree root entry');\n        matches.shift(); // The first entry is the full match\n        const [eRoot, lRoot, seq, signature] = matches;\n        assert_1.default.ok(eRoot, \"Could not parse 'e' value from ENRTree root entry\");\n        assert_1.default.ok(lRoot, \"Could not parse 'l' value from ENRTree root entry\");\n        assert_1.default.ok(seq, \"Could not parse 'seq' value from ENRTree root entry\");\n        assert_1.default.ok(signature, \"Could not parse 'sig' value from ENRTree root entry\");\n        return { eRoot, lRoot, seq: Number(seq), signature };\n    }\n    /**\n     * Returns the public key and top level domain of an ENR tree entry.\n     * The domain is the starting point for traversing a set of linked DNS TXT records\n     * and the public key is used to verify the root entry record\n     */\n    static parseTree(tree) {\n        assert_1.default(tree.startsWith(this.TREE_PREFIX), `ENRTree tree entry must start with '${this.TREE_PREFIX}'`);\n        const matches = tree.match(/^enrtree:\\/\\/([^@]+)@(.+)$/);\n        assert_1.default.ok(Array.isArray(matches), 'Could not parse ENRTree tree entry');\n        matches.shift(); // The first entry is the full match\n        const [publicKey, domain] = matches;\n        assert_1.default.ok(publicKey, 'Could not parse public key from ENRTree tree entry');\n        assert_1.default.ok(domain, 'Could not parse domain from ENRTree tree entry');\n        return { publicKey, domain };\n    }\n    /**\n     * Returns subdomains listed in an ENR branch entry. These in turn lead to\n     * either further branch entries or ENR records.\n     */\n    static parseBranch(branch) {\n        assert_1.default(branch.startsWith(this.BRANCH_PREFIX), `ENRTree branch entry must start with '${this.BRANCH_PREFIX}'`);\n        return branch.split(this.BRANCH_PREFIX)[1].split(',');\n    }\n}\nexports.ENRTree = ENRTree;\nENRTree.RECORD_PREFIX = enr_1.ENR.RECORD_PREFIX;\nENRTree.TREE_PREFIX = 'enrtree:';\nENRTree.BRANCH_PREFIX = 'enrtree-branch:';\nENRTree.ROOT_PREFIX = 'enrtree-root:';\n//# sourceMappingURL=enrtree.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.keccak256Buf = exports.equalByteArrays = exports.bufToHex = exports.hexToBuf = void 0;\nconst js_sha3_1 = require(\"js-sha3\");\nfunction hexToBuf(hex) {\n    if (typeof hex === 'string') {\n        return Buffer.from(hex.replace(/^0x/i, ''), 'hex');\n    }\n    else {\n        return Buffer.from(hex);\n    }\n}\nexports.hexToBuf = hexToBuf;\nfunction bufToHex(buf) {\n    const _buf = Buffer.from(buf);\n    return _buf.toString('hex');\n}\nexports.bufToHex = bufToHex;\nfunction equalByteArrays(a, b) {\n    let aBuf;\n    let bBuf;\n    if (typeof a === 'string') {\n        aBuf = hexToBuf(a);\n    }\n    else {\n        aBuf = Buffer.from(a);\n    }\n    if (typeof b === 'string') {\n        bBuf = hexToBuf(b);\n    }\n    else {\n        bBuf = Buffer.from(b);\n    }\n    return aBuf.compare(bBuf) === 0;\n}\nexports.equalByteArrays = equalByteArrays;\nfunction keccak256Buf(message) {\n    return Buffer.from(js_sha3_1.keccak256.arrayBuffer(message));\n}\nexports.keccak256Buf = keccak256Buf;\n//# sourceMappingURL=utils.js.map","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PushRPC = exports.PushResponse = exports.PushRequest = exports.protobufPackage = void 0;\n/* eslint-disable */\nconst long_1 = __importDefault(require(\"long\"));\nconst minimal_1 = __importDefault(require(\"protobufjs/minimal\"));\nconst message_1 = require(\"../../waku/v2/message\");\nexports.protobufPackage = 'waku.v2';\nfunction createBasePushRequest() {\n    return { pubSubTopic: '', message: undefined };\n}\nexports.PushRequest = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.pubSubTopic !== '') {\n            writer.uint32(10).string(message.pubSubTopic);\n        }\n        if (message.message !== undefined) {\n            message_1.WakuMessage.encode(message.message, writer.uint32(18).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBasePushRequest();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.pubSubTopic = reader.string();\n                    break;\n                case 2:\n                    message.message = message_1.WakuMessage.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            pubSubTopic: isSet(object.pubSubTopic) ? String(object.pubSubTopic) : '',\n            message: isSet(object.message)\n                ? message_1.WakuMessage.fromJSON(object.message)\n                : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.pubSubTopic !== undefined &&\n            (obj.pubSubTopic = message.pubSubTopic);\n        message.message !== undefined &&\n            (obj.message = message.message\n                ? message_1.WakuMessage.toJSON(message.message)\n                : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        const message = createBasePushRequest();\n        message.pubSubTopic = object.pubSubTopic ?? '';\n        message.message =\n            object.message !== undefined && object.message !== null\n                ? message_1.WakuMessage.fromPartial(object.message)\n                : undefined;\n        return message;\n    },\n};\nfunction createBasePushResponse() {\n    return { isSuccess: false, info: '' };\n}\nexports.PushResponse = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.isSuccess === true) {\n            writer.uint32(8).bool(message.isSuccess);\n        }\n        if (message.info !== '') {\n            writer.uint32(18).string(message.info);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBasePushResponse();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.isSuccess = reader.bool();\n                    break;\n                case 2:\n                    message.info = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            isSuccess: isSet(object.isSuccess) ? Boolean(object.isSuccess) : false,\n            info: isSet(object.info) ? String(object.info) : '',\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.isSuccess !== undefined && (obj.isSuccess = message.isSuccess);\n        message.info !== undefined && (obj.info = message.info);\n        return obj;\n    },\n    fromPartial(object) {\n        const message = createBasePushResponse();\n        message.isSuccess = object.isSuccess ?? false;\n        message.info = object.info ?? '';\n        return message;\n    },\n};\nfunction createBasePushRPC() {\n    return { requestId: '', request: undefined, response: undefined };\n}\nexports.PushRPC = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.requestId !== '') {\n            writer.uint32(10).string(message.requestId);\n        }\n        if (message.request !== undefined) {\n            exports.PushRequest.encode(message.request, writer.uint32(18).fork()).ldelim();\n        }\n        if (message.response !== undefined) {\n            exports.PushResponse.encode(message.response, writer.uint32(26).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBasePushRPC();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.requestId = reader.string();\n                    break;\n                case 2:\n                    message.request = exports.PushRequest.decode(reader, reader.uint32());\n                    break;\n                case 3:\n                    message.response = exports.PushResponse.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            requestId: isSet(object.requestId) ? String(object.requestId) : '',\n            request: isSet(object.request)\n                ? exports.PushRequest.fromJSON(object.request)\n                : undefined,\n            response: isSet(object.response)\n                ? exports.PushResponse.fromJSON(object.response)\n                : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.requestId !== undefined && (obj.requestId = message.requestId);\n        message.request !== undefined &&\n            (obj.request = message.request\n                ? exports.PushRequest.toJSON(message.request)\n                : undefined);\n        message.response !== undefined &&\n            (obj.response = message.response\n                ? exports.PushResponse.toJSON(message.response)\n                : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        const message = createBasePushRPC();\n        message.requestId = object.requestId ?? '';\n        message.request =\n            object.request !== undefined && object.request !== null\n                ? exports.PushRequest.fromPartial(object.request)\n                : undefined;\n        message.response =\n            object.response !== undefined && object.response !== null\n                ? exports.PushResponse.fromPartial(object.response)\n                : undefined;\n        return message;\n    },\n};\nif (minimal_1.default.util.Long !== long_1.default) {\n    minimal_1.default.util.Long = long_1.default;\n    minimal_1.default.configure();\n}\nfunction isSet(value) {\n    return value !== null && value !== undefined;\n}\n//# sourceMappingURL=light_push.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getPublicKey = exports.generateSymmetricKey = exports.generatePrivateKey = exports.decryptSymmetric = exports.encryptSymmetric = exports.decryptAsymmetric = exports.encryptAsymmetric = exports.clearDecode = exports.clearEncode = exports.PrivateKeySize = void 0;\nconst buffer_1 = require(\"buffer\");\nconst crypto = __importStar(require(\"crypto\"));\nconst ecies = __importStar(require(\"ecies-geth\"));\nconst js_sha3_1 = require(\"js-sha3\");\nconst secp256k1 = __importStar(require(\"secp256k1\"));\nconst utils_1 = require(\"../utils\");\nconst symmetric_1 = require(\"./symmetric\");\nconst FlagsLength = 1;\nconst FlagMask = 3; // 0011\nconst IsSignedMask = 4; // 0100\nconst PaddingTarget = 256;\nconst SignatureLength = 65;\nexports.PrivateKeySize = 32;\n/**\n * Encode the payload pre-encryption.\n *\n * @internal\n * @param messagePayload: The payload to include in the message\n * @param sigPrivKey: If set, a signature using this private key is added.\n * @returns The encoded payload, ready for encryption using {@link encryptAsymmetric}\n * or {@link encryptSymmetric}.\n */\nfunction clearEncode(messagePayload, sigPrivKey) {\n    let envelope = buffer_1.Buffer.from([0]); // No flags\n    envelope = addPayloadSizeField(envelope, messagePayload);\n    envelope = buffer_1.Buffer.concat([envelope, buffer_1.Buffer.from(messagePayload)]);\n    // Calculate padding:\n    let rawSize = FlagsLength +\n        getSizeOfPayloadSizeField(messagePayload) +\n        messagePayload.length;\n    if (sigPrivKey) {\n        rawSize += SignatureLength;\n    }\n    const remainder = rawSize % PaddingTarget;\n    const paddingSize = PaddingTarget - remainder;\n    const pad = buffer_1.Buffer.from(randomBytes(paddingSize));\n    if (!validateDataIntegrity(pad, paddingSize)) {\n        throw new Error('failed to generate random padding of size ' + paddingSize);\n    }\n    envelope = buffer_1.Buffer.concat([envelope, pad]);\n    let sig;\n    if (sigPrivKey) {\n        envelope[0] |= IsSignedMask;\n        const hash = js_sha3_1.keccak256(envelope);\n        const s = secp256k1.ecdsaSign(utils_1.hexToBuf(hash), sigPrivKey);\n        envelope = buffer_1.Buffer.concat([envelope, s.signature, buffer_1.Buffer.from([s.recid])]);\n        sig = {\n            signature: buffer_1.Buffer.from(s.signature),\n            publicKey: getPublicKey(sigPrivKey),\n        };\n    }\n    return { payload: envelope, sig };\n}\nexports.clearEncode = clearEncode;\n/**\n * Decode a decrypted payload.\n *\n * @internal\n */\nfunction clearDecode(message) {\n    const buf = buffer_1.Buffer.from(message);\n    let start = 1;\n    let sig;\n    const sizeOfPayloadSizeField = buf.readUIntLE(0, 1) & FlagMask;\n    if (sizeOfPayloadSizeField === 0)\n        return;\n    const payloadSize = buf.readUIntLE(start, sizeOfPayloadSizeField);\n    start += sizeOfPayloadSizeField;\n    const payload = buf.slice(start, start + payloadSize);\n    const isSigned = (buf.readUIntLE(0, 1) & IsSignedMask) == IsSignedMask;\n    if (isSigned) {\n        const signature = getSignature(buf);\n        const hash = getHash(buf, isSigned);\n        const publicKey = ecRecoverPubKey(hash, signature);\n        sig = { signature, publicKey };\n    }\n    return { payload, sig };\n}\nexports.clearDecode = clearDecode;\n/**\n * Proceed with Asymmetric encryption of the data as per [26/WAKU-PAYLOAD](https://rfc.vac.dev/spec/26/).\n * The data MUST be flags | payload-length | payload | [signature].\n * The returned result can be set to `WakuMessage.payload`.\n *\n * @internal\n */\nasync function encryptAsymmetric(data, publicKey) {\n    return ecies.encrypt(utils_1.hexToBuf(publicKey), buffer_1.Buffer.from(data));\n}\nexports.encryptAsymmetric = encryptAsymmetric;\n/**\n * Proceed with Asymmetric decryption of the data as per [26/WAKU-PAYLOAD](https://rfc.vac.dev/spec/26/).\n * The return data is expect to be flags | payload-length | payload | [signature].\n *\n * @internal\n */\nasync function decryptAsymmetric(payload, privKey) {\n    return ecies.decrypt(buffer_1.Buffer.from(privKey), buffer_1.Buffer.from(payload));\n}\nexports.decryptAsymmetric = decryptAsymmetric;\n/**\n * Proceed with Symmetric encryption of the data as per [26/WAKU-PAYLOAD](https://rfc.vac.dev/spec/26/).\n *\n * @param data The data to encrypt, expected to be `flags | payload-length | payload | [signature]`.\n * @param key The key to use for encryption.\n * @returns The decrypted data, `cipherText | tag | iv` and can be set to `WakuMessage.payload`.\n *\n * @internal\n */\nasync function encryptSymmetric(data, key) {\n    const iv = symmetric_1.symmetric.generateIv();\n    // Returns `cipher | tag`\n    const cipher = await symmetric_1.symmetric.encrypt(iv, utils_1.hexToBuf(key), buffer_1.Buffer.from(data));\n    return buffer_1.Buffer.concat([cipher, buffer_1.Buffer.from(iv)]);\n}\nexports.encryptSymmetric = encryptSymmetric;\n/**\n * Proceed with Symmetric decryption of the data as per [26/WAKU-PAYLOAD](https://rfc.vac.dev/spec/26/).\n *\n * @param payload The cipher data, it is expected to be `cipherText | tag | iv`.\n * @param key The key to use for decryption.\n * @returns The decrypted data, expected to be `flags | payload-length | payload | [signature]`.\n *\n * @internal\n */\nasync function decryptSymmetric(payload, key) {\n    const data = buffer_1.Buffer.from(payload);\n    const ivStart = data.length - symmetric_1.IvSize;\n    const cipher = data.slice(0, ivStart);\n    const iv = data.slice(ivStart);\n    return symmetric_1.symmetric.decrypt(iv, utils_1.hexToBuf(key), cipher);\n}\nexports.decryptSymmetric = decryptSymmetric;\n/**\n * Generate a new private key to be used for asymmetric encryption.\n *\n * Use {@link getPublicKey} to get the corresponding Public Key.\n */\nfunction generatePrivateKey() {\n    return randomBytes(exports.PrivateKeySize);\n}\nexports.generatePrivateKey = generatePrivateKey;\n/**\n * Generate a new symmetric key to be used for symmetric encryption.\n */\nfunction generateSymmetricKey() {\n    return randomBytes(symmetric_1.SymmetricKeySize);\n}\nexports.generateSymmetricKey = generateSymmetricKey;\n/**\n * Return the public key for the given private key, to be used for asymmetric\n * encryption.\n */\nfunction getPublicKey(privateKey) {\n    return secp256k1.publicKeyCreate(privateKey, false);\n}\nexports.getPublicKey = getPublicKey;\n/**\n * Computes the flags & auxiliary-field as per [26/WAKU-PAYLOAD](https://rfc.vac.dev/spec/26/).\n */\nfunction addPayloadSizeField(msg, payload) {\n    const fieldSize = getSizeOfPayloadSizeField(payload);\n    let field = buffer_1.Buffer.alloc(4);\n    field.writeUInt32LE(payload.length, 0);\n    field = field.slice(0, fieldSize);\n    msg = buffer_1.Buffer.concat([msg, field]);\n    msg[0] |= fieldSize;\n    return msg;\n}\n/**\n * Returns the size of the auxiliary-field which in turns contains the payload size\n */\nfunction getSizeOfPayloadSizeField(payload) {\n    let s = 1;\n    for (let i = payload.length; i >= 256; i /= 256) {\n        s++;\n    }\n    return s;\n}\nfunction validateDataIntegrity(value, expectedSize) {\n    if (value.length !== expectedSize) {\n        return false;\n    }\n    return !(expectedSize > 3 && buffer_1.Buffer.from(value).equals(buffer_1.Buffer.alloc(value.length)));\n}\nfunction getSignature(message) {\n    return message.slice(message.length - SignatureLength, message.length);\n}\nfunction getHash(message, isSigned) {\n    if (isSigned) {\n        return js_sha3_1.keccak256(message.slice(0, message.length - SignatureLength));\n    }\n    return js_sha3_1.keccak256(message);\n}\nfunction ecRecoverPubKey(messageHash, signature) {\n    const recovery = signature.slice(64).readIntBE(0, 1);\n    return secp256k1.ecdsaRecover(signature.slice(0, 64), recovery, utils_1.hexToBuf(messageHash), false);\n}\nfunction randomBytes(length) {\n    if (typeof window !== 'undefined' && window && window.crypto) {\n        const array = new Uint8Array(length);\n        window.crypto.getRandomValues(array);\n        return array;\n    }\n    else {\n        return crypto.randomBytes(length);\n    }\n}\n//# sourceMappingURL=version_1.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getRelayPeers = void 0;\nconst utils_1 = require(\"libp2p-gossipsub/src/utils\");\nconst index_1 = require(\"./index\");\n/**\n * Given a topic, returns up to count peers subscribed to that topic\n * that pass an optional filter function\n *\n * @param {Gossipsub} router\n * @param {String} topic\n * @param {Number} count\n * @param {Function} [filter] a function to filter acceptable peers\n * @returns {Set<string>}\n *\n */\nfunction getRelayPeers(router, topic, count, filter = () => true) {\n    const peersInTopic = router.topics.get(topic);\n    if (!peersInTopic) {\n        return new Set();\n    }\n    // Adds all peers using our protocol\n    // that also pass the filter function\n    let peers = [];\n    peersInTopic.forEach((id) => {\n        const peerStreams = router.peers.get(id);\n        if (!peerStreams) {\n            return;\n        }\n        if (index_1.RelayCodecs.includes(peerStreams.protocol) && filter(id)) {\n            peers.push(id);\n        }\n    });\n    // Pseudo-randomly shuffles peers\n    peers = utils_1.shuffle(peers);\n    if (count > 0 && peers.length > count) {\n        peers = peers.slice(0, count);\n    }\n    return new Set(peers);\n}\nexports.getRelayPeers = getRelayPeers;\n//# sourceMappingURL=get_relay_peers.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.HistoryRPC = exports.HistoryResponse_Error = exports.HistoryResponse = exports.HistoryQuery = exports.ContentFilter = exports.PagingInfo_Direction = exports.PagingInfo = exports.Index = exports.WakuMessage = void 0;\nvar message_1 = require(\"./waku/v2/message\");\nObject.defineProperty(exports, \"WakuMessage\", { enumerable: true, get: function () { return message_1.WakuMessage; } });\nvar store_1 = require(\"./waku/v2/store\");\nObject.defineProperty(exports, \"Index\", { enumerable: true, get: function () { return store_1.Index; } });\nObject.defineProperty(exports, \"PagingInfo\", { enumerable: true, get: function () { return store_1.PagingInfo; } });\nObject.defineProperty(exports, \"PagingInfo_Direction\", { enumerable: true, get: function () { return store_1.PagingInfo_Direction; } });\nObject.defineProperty(exports, \"ContentFilter\", { enumerable: true, get: function () { return store_1.ContentFilter; } });\nObject.defineProperty(exports, \"HistoryQuery\", { enumerable: true, get: function () { return store_1.HistoryQuery; } });\nObject.defineProperty(exports, \"HistoryResponse\", { enumerable: true, get: function () { return store_1.HistoryResponse; } });\nObject.defineProperty(exports, \"HistoryResponse_Error\", { enumerable: true, get: function () { return store_1.HistoryResponse_Error; } });\nObject.defineProperty(exports, \"HistoryRPC\", { enumerable: true, get: function () { return store_1.HistoryRPC; } });\n//# sourceMappingURL=index.js.map","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.HistoryRPC = exports.HistoryResponse = exports.HistoryQuery = exports.ContentFilter = exports.PagingInfo = exports.Index = exports.historyResponse_ErrorToJSON = exports.historyResponse_ErrorFromJSON = exports.HistoryResponse_Error = exports.pagingInfo_DirectionToJSON = exports.pagingInfo_DirectionFromJSON = exports.PagingInfo_Direction = exports.protobufPackage = void 0;\n/* eslint-disable */\nconst long_1 = __importDefault(require(\"long\"));\nconst minimal_1 = __importDefault(require(\"protobufjs/minimal\"));\nconst message_1 = require(\"../../waku/v2/message\");\nexports.protobufPackage = 'waku.v2';\nvar PagingInfo_Direction;\n(function (PagingInfo_Direction) {\n    PagingInfo_Direction[PagingInfo_Direction[\"DIRECTION_BACKWARD_UNSPECIFIED\"] = 0] = \"DIRECTION_BACKWARD_UNSPECIFIED\";\n    PagingInfo_Direction[PagingInfo_Direction[\"DIRECTION_FORWARD\"] = 1] = \"DIRECTION_FORWARD\";\n    PagingInfo_Direction[PagingInfo_Direction[\"UNRECOGNIZED\"] = -1] = \"UNRECOGNIZED\";\n})(PagingInfo_Direction = exports.PagingInfo_Direction || (exports.PagingInfo_Direction = {}));\nfunction pagingInfo_DirectionFromJSON(object) {\n    switch (object) {\n        case 0:\n        case 'DIRECTION_BACKWARD_UNSPECIFIED':\n            return PagingInfo_Direction.DIRECTION_BACKWARD_UNSPECIFIED;\n        case 1:\n        case 'DIRECTION_FORWARD':\n            return PagingInfo_Direction.DIRECTION_FORWARD;\n        case -1:\n        case 'UNRECOGNIZED':\n        default:\n            return PagingInfo_Direction.UNRECOGNIZED;\n    }\n}\nexports.pagingInfo_DirectionFromJSON = pagingInfo_DirectionFromJSON;\nfunction pagingInfo_DirectionToJSON(object) {\n    switch (object) {\n        case PagingInfo_Direction.DIRECTION_BACKWARD_UNSPECIFIED:\n            return 'DIRECTION_BACKWARD_UNSPECIFIED';\n        case PagingInfo_Direction.DIRECTION_FORWARD:\n            return 'DIRECTION_FORWARD';\n        default:\n            return 'UNKNOWN';\n    }\n}\nexports.pagingInfo_DirectionToJSON = pagingInfo_DirectionToJSON;\nvar HistoryResponse_Error;\n(function (HistoryResponse_Error) {\n    HistoryResponse_Error[HistoryResponse_Error[\"ERROR_NONE_UNSPECIFIED\"] = 0] = \"ERROR_NONE_UNSPECIFIED\";\n    HistoryResponse_Error[HistoryResponse_Error[\"ERROR_INVALID_CURSOR\"] = 1] = \"ERROR_INVALID_CURSOR\";\n    HistoryResponse_Error[HistoryResponse_Error[\"UNRECOGNIZED\"] = -1] = \"UNRECOGNIZED\";\n})(HistoryResponse_Error = exports.HistoryResponse_Error || (exports.HistoryResponse_Error = {}));\nfunction historyResponse_ErrorFromJSON(object) {\n    switch (object) {\n        case 0:\n        case 'ERROR_NONE_UNSPECIFIED':\n            return HistoryResponse_Error.ERROR_NONE_UNSPECIFIED;\n        case 1:\n        case 'ERROR_INVALID_CURSOR':\n            return HistoryResponse_Error.ERROR_INVALID_CURSOR;\n        case -1:\n        case 'UNRECOGNIZED':\n        default:\n            return HistoryResponse_Error.UNRECOGNIZED;\n    }\n}\nexports.historyResponse_ErrorFromJSON = historyResponse_ErrorFromJSON;\nfunction historyResponse_ErrorToJSON(object) {\n    switch (object) {\n        case HistoryResponse_Error.ERROR_NONE_UNSPECIFIED:\n            return 'ERROR_NONE_UNSPECIFIED';\n        case HistoryResponse_Error.ERROR_INVALID_CURSOR:\n            return 'ERROR_INVALID_CURSOR';\n        default:\n            return 'UNKNOWN';\n    }\n}\nexports.historyResponse_ErrorToJSON = historyResponse_ErrorToJSON;\nfunction createBaseIndex() {\n    return { digest: new Uint8Array(), receivedTime: 0, senderTime: 0 };\n}\nexports.Index = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.digest.length !== 0) {\n            writer.uint32(10).bytes(message.digest);\n        }\n        if (message.receivedTime !== 0) {\n            writer.uint32(17).double(message.receivedTime);\n        }\n        if (message.senderTime !== 0) {\n            writer.uint32(25).double(message.senderTime);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseIndex();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.digest = reader.bytes();\n                    break;\n                case 2:\n                    message.receivedTime = reader.double();\n                    break;\n                case 3:\n                    message.senderTime = reader.double();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            digest: isSet(object.digest)\n                ? bytesFromBase64(object.digest)\n                : new Uint8Array(),\n            receivedTime: isSet(object.receivedTime)\n                ? Number(object.receivedTime)\n                : 0,\n            senderTime: isSet(object.senderTime) ? Number(object.senderTime) : 0,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.digest !== undefined &&\n            (obj.digest = base64FromBytes(message.digest !== undefined ? message.digest : new Uint8Array()));\n        message.receivedTime !== undefined &&\n            (obj.receivedTime = message.receivedTime);\n        message.senderTime !== undefined && (obj.senderTime = message.senderTime);\n        return obj;\n    },\n    fromPartial(object) {\n        const message = createBaseIndex();\n        message.digest = object.digest ?? new Uint8Array();\n        message.receivedTime = object.receivedTime ?? 0;\n        message.senderTime = object.senderTime ?? 0;\n        return message;\n    },\n};\nfunction createBasePagingInfo() {\n    return { pageSize: 0, cursor: undefined, direction: 0 };\n}\nexports.PagingInfo = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.pageSize !== 0) {\n            writer.uint32(8).uint64(message.pageSize);\n        }\n        if (message.cursor !== undefined) {\n            exports.Index.encode(message.cursor, writer.uint32(18).fork()).ldelim();\n        }\n        if (message.direction !== 0) {\n            writer.uint32(24).int32(message.direction);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBasePagingInfo();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.pageSize = longToNumber(reader.uint64());\n                    break;\n                case 2:\n                    message.cursor = exports.Index.decode(reader, reader.uint32());\n                    break;\n                case 3:\n                    message.direction = reader.int32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            pageSize: isSet(object.pageSize) ? Number(object.pageSize) : 0,\n            cursor: isSet(object.cursor) ? exports.Index.fromJSON(object.cursor) : undefined,\n            direction: isSet(object.direction)\n                ? pagingInfo_DirectionFromJSON(object.direction)\n                : 0,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.pageSize !== undefined &&\n            (obj.pageSize = Math.round(message.pageSize));\n        message.cursor !== undefined &&\n            (obj.cursor = message.cursor ? exports.Index.toJSON(message.cursor) : undefined);\n        message.direction !== undefined &&\n            (obj.direction = pagingInfo_DirectionToJSON(message.direction));\n        return obj;\n    },\n    fromPartial(object) {\n        const message = createBasePagingInfo();\n        message.pageSize = object.pageSize ?? 0;\n        message.cursor =\n            object.cursor !== undefined && object.cursor !== null\n                ? exports.Index.fromPartial(object.cursor)\n                : undefined;\n        message.direction = object.direction ?? 0;\n        return message;\n    },\n};\nfunction createBaseContentFilter() {\n    return { contentTopic: '' };\n}\nexports.ContentFilter = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.contentTopic !== '') {\n            writer.uint32(10).string(message.contentTopic);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseContentFilter();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.contentTopic = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            contentTopic: isSet(object.contentTopic)\n                ? String(object.contentTopic)\n                : '',\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.contentTopic !== undefined &&\n            (obj.contentTopic = message.contentTopic);\n        return obj;\n    },\n    fromPartial(object) {\n        const message = createBaseContentFilter();\n        message.contentTopic = object.contentTopic ?? '';\n        return message;\n    },\n};\nfunction createBaseHistoryQuery() {\n    return {\n        pubSubTopic: undefined,\n        contentFilters: [],\n        pagingInfo: undefined,\n        startTime: undefined,\n        endTime: undefined,\n    };\n}\nexports.HistoryQuery = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.pubSubTopic !== undefined) {\n            writer.uint32(18).string(message.pubSubTopic);\n        }\n        for (const v of message.contentFilters) {\n            exports.ContentFilter.encode(v, writer.uint32(26).fork()).ldelim();\n        }\n        if (message.pagingInfo !== undefined) {\n            exports.PagingInfo.encode(message.pagingInfo, writer.uint32(34).fork()).ldelim();\n        }\n        if (message.startTime !== undefined) {\n            writer.uint32(41).double(message.startTime);\n        }\n        if (message.endTime !== undefined) {\n            writer.uint32(49).double(message.endTime);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseHistoryQuery();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 2:\n                    message.pubSubTopic = reader.string();\n                    break;\n                case 3:\n                    message.contentFilters.push(exports.ContentFilter.decode(reader, reader.uint32()));\n                    break;\n                case 4:\n                    message.pagingInfo = exports.PagingInfo.decode(reader, reader.uint32());\n                    break;\n                case 5:\n                    message.startTime = reader.double();\n                    break;\n                case 6:\n                    message.endTime = reader.double();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            pubSubTopic: isSet(object.pubSubTopic)\n                ? String(object.pubSubTopic)\n                : undefined,\n            contentFilters: Array.isArray(object?.contentFilters)\n                ? object.contentFilters.map((e) => exports.ContentFilter.fromJSON(e))\n                : [],\n            pagingInfo: isSet(object.pagingInfo)\n                ? exports.PagingInfo.fromJSON(object.pagingInfo)\n                : undefined,\n            startTime: isSet(object.startTime) ? Number(object.startTime) : undefined,\n            endTime: isSet(object.endTime) ? Number(object.endTime) : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.pubSubTopic !== undefined &&\n            (obj.pubSubTopic = message.pubSubTopic);\n        if (message.contentFilters) {\n            obj.contentFilters = message.contentFilters.map((e) => e ? exports.ContentFilter.toJSON(e) : undefined);\n        }\n        else {\n            obj.contentFilters = [];\n        }\n        message.pagingInfo !== undefined &&\n            (obj.pagingInfo = message.pagingInfo\n                ? exports.PagingInfo.toJSON(message.pagingInfo)\n                : undefined);\n        message.startTime !== undefined && (obj.startTime = message.startTime);\n        message.endTime !== undefined && (obj.endTime = message.endTime);\n        return obj;\n    },\n    fromPartial(object) {\n        const message = createBaseHistoryQuery();\n        message.pubSubTopic = object.pubSubTopic ?? undefined;\n        message.contentFilters =\n            object.contentFilters?.map((e) => exports.ContentFilter.fromPartial(e)) || [];\n        message.pagingInfo =\n            object.pagingInfo !== undefined && object.pagingInfo !== null\n                ? exports.PagingInfo.fromPartial(object.pagingInfo)\n                : undefined;\n        message.startTime = object.startTime ?? undefined;\n        message.endTime = object.endTime ?? undefined;\n        return message;\n    },\n};\nfunction createBaseHistoryResponse() {\n    return { messages: [], pagingInfo: undefined, error: 0 };\n}\nexports.HistoryResponse = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        for (const v of message.messages) {\n            message_1.WakuMessage.encode(v, writer.uint32(18).fork()).ldelim();\n        }\n        if (message.pagingInfo !== undefined) {\n            exports.PagingInfo.encode(message.pagingInfo, writer.uint32(26).fork()).ldelim();\n        }\n        if (message.error !== 0) {\n            writer.uint32(32).int32(message.error);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseHistoryResponse();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 2:\n                    message.messages.push(message_1.WakuMessage.decode(reader, reader.uint32()));\n                    break;\n                case 3:\n                    message.pagingInfo = exports.PagingInfo.decode(reader, reader.uint32());\n                    break;\n                case 4:\n                    message.error = reader.int32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            messages: Array.isArray(object?.messages)\n                ? object.messages.map((e) => message_1.WakuMessage.fromJSON(e))\n                : [],\n            pagingInfo: isSet(object.pagingInfo)\n                ? exports.PagingInfo.fromJSON(object.pagingInfo)\n                : undefined,\n            error: isSet(object.error)\n                ? historyResponse_ErrorFromJSON(object.error)\n                : 0,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.messages) {\n            obj.messages = message.messages.map((e) => e ? message_1.WakuMessage.toJSON(e) : undefined);\n        }\n        else {\n            obj.messages = [];\n        }\n        message.pagingInfo !== undefined &&\n            (obj.pagingInfo = message.pagingInfo\n                ? exports.PagingInfo.toJSON(message.pagingInfo)\n                : undefined);\n        message.error !== undefined &&\n            (obj.error = historyResponse_ErrorToJSON(message.error));\n        return obj;\n    },\n    fromPartial(object) {\n        const message = createBaseHistoryResponse();\n        message.messages =\n            object.messages?.map((e) => message_1.WakuMessage.fromPartial(e)) || [];\n        message.pagingInfo =\n            object.pagingInfo !== undefined && object.pagingInfo !== null\n                ? exports.PagingInfo.fromPartial(object.pagingInfo)\n                : undefined;\n        message.error = object.error ?? 0;\n        return message;\n    },\n};\nfunction createBaseHistoryRPC() {\n    return { requestId: '', query: undefined, response: undefined };\n}\nexports.HistoryRPC = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.requestId !== '') {\n            writer.uint32(10).string(message.requestId);\n        }\n        if (message.query !== undefined) {\n            exports.HistoryQuery.encode(message.query, writer.uint32(18).fork()).ldelim();\n        }\n        if (message.response !== undefined) {\n            exports.HistoryResponse.encode(message.response, writer.uint32(26).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseHistoryRPC();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.requestId = reader.string();\n                    break;\n                case 2:\n                    message.query = exports.HistoryQuery.decode(reader, reader.uint32());\n                    break;\n                case 3:\n                    message.response = exports.HistoryResponse.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            requestId: isSet(object.requestId) ? String(object.requestId) : '',\n            query: isSet(object.query)\n                ? exports.HistoryQuery.fromJSON(object.query)\n                : undefined,\n            response: isSet(object.response)\n                ? exports.HistoryResponse.fromJSON(object.response)\n                : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.requestId !== undefined && (obj.requestId = message.requestId);\n        message.query !== undefined &&\n            (obj.query = message.query\n                ? exports.HistoryQuery.toJSON(message.query)\n                : undefined);\n        message.response !== undefined &&\n            (obj.response = message.response\n                ? exports.HistoryResponse.toJSON(message.response)\n                : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        const message = createBaseHistoryRPC();\n        message.requestId = object.requestId ?? '';\n        message.query =\n            object.query !== undefined && object.query !== null\n                ? exports.HistoryQuery.fromPartial(object.query)\n                : undefined;\n        message.response =\n            object.response !== undefined && object.response !== null\n                ? exports.HistoryResponse.fromPartial(object.response)\n                : undefined;\n        return message;\n    },\n};\nvar globalThis = (() => {\n    if (typeof globalThis !== 'undefined')\n        return globalThis;\n    if (typeof self !== 'undefined')\n        return self;\n    if (typeof window !== 'undefined')\n        return window;\n    if (typeof global !== 'undefined')\n        return global;\n    throw 'Unable to locate global object';\n})();\nconst atob = globalThis.atob ||\n    ((b64) => globalThis.Buffer.from(b64, 'base64').toString('binary'));\nfunction bytesFromBase64(b64) {\n    const bin = atob(b64);\n    const arr = new Uint8Array(bin.length);\n    for (let i = 0; i < bin.length; ++i) {\n        arr[i] = bin.charCodeAt(i);\n    }\n    return arr;\n}\nconst btoa = globalThis.btoa ||\n    ((bin) => globalThis.Buffer.from(bin, 'binary').toString('base64'));\nfunction base64FromBytes(arr) {\n    const bin = [];\n    for (const byte of arr) {\n        bin.push(String.fromCharCode(byte));\n    }\n    return btoa(bin.join(''));\n}\nfunction longToNumber(long) {\n    if (long.gt(Number.MAX_SAFE_INTEGER)) {\n        throw new globalThis.Error('Value is larger than Number.MAX_SAFE_INTEGER');\n    }\n    return long.toNumber();\n}\nif (minimal_1.default.util.Long !== long_1.default) {\n    minimal_1.default.util.Long = long_1.default;\n    minimal_1.default.configure();\n}\nfunction isSet(value) {\n    return value !== null && value !== undefined;\n}\n//# sourceMappingURL=store.js.map","import {\n  FormControl,\n  InputLabel,\n  makeStyles,\n  MenuItem,\n  Select,\n  TextField,\n} from '@material-ui/core';\nimport React, { ChangeEvent, useState, KeyboardEvent } from 'react';\nimport { Waku, WakuMessage } from 'js-waku';\nimport { bufToHex, hexToBuf } from 'js-waku/lib/utils';\nimport { PrivateMessage } from './wire';\nimport { PrivateMessageContentTopic } from '../waku';\nimport * as sigUtil from 'eth-sig-util';\n\nconst useStyles = makeStyles((theme) => ({\n  formControl: {\n    margin: theme.spacing(1),\n    minWidth: 120,\n  },\n  selectEmpty: {\n    marginTop: theme.spacing(2),\n  },\n}));\n\nexport interface Props {\n  waku: Waku | undefined;\n  // address, public key\n  recipients: Map<string, Uint8Array>;\n}\n\nexport default function SendMessage({ waku, recipients }: Props) {\n  const classes = useStyles();\n  const [recipient, setRecipient] = useState<string>('');\n  const [message, setMessage] = useState<string>();\n\n  const handleRecipientChange = (\n    event: ChangeEvent<{ name?: string; value: unknown }>\n  ) => {\n    setRecipient(event.target.value as string);\n  };\n\n  const handleMessageChange = (event: ChangeEvent<HTMLInputElement>) => {\n    setMessage(event.target.value);\n  };\n\n  const items = Array.from(recipients.keys()).map((recipient) => {\n    return (\n      <MenuItem key={recipient} value={recipient}>\n        {recipient}\n      </MenuItem>\n    );\n  });\n\n  const keyDownHandler = async (event: KeyboardEvent<HTMLInputElement>) => {\n    if (\n      event.key === 'Enter' &&\n      !event.altKey &&\n      !event.ctrlKey &&\n      !event.shiftKey\n    ) {\n      if (!waku) return;\n      if (!recipient) return;\n      if (!message) return;\n      const publicKey = recipients.get(recipient);\n      if (!publicKey) return;\n\n      sendMessage(waku, recipient, publicKey, message, (res) => {\n        if (res) {\n          console.log('callback called with', res);\n          setMessage('');\n        }\n      });\n    }\n  };\n\n  return (\n    <div\n      style={{\n        display: 'flex',\n        alignItems: 'center',\n        flexWrap: 'wrap',\n      }}\n    >\n      <FormControl className={classes.formControl}>\n        <InputLabel id=\"select-recipient-label\">Recipient</InputLabel>\n        <Select\n          labelId=\"select-recipient\"\n          id=\"select-recipient\"\n          value={recipient}\n          onChange={handleRecipientChange}\n        >\n          {items}\n        </Select>\n      </FormControl>\n      <TextField\n        id=\"message-input\"\n        label=\"Message\"\n        variant=\"filled\"\n        onChange={handleMessageChange}\n        onKeyDown={keyDownHandler}\n        value={message}\n      />\n    </div>\n  );\n}\n\nasync function encodeEncryptedWakuMessage(\n  message: string,\n  publicKey: Uint8Array,\n  address: string\n): Promise<WakuMessage> {\n  const privateMessage = new PrivateMessage({\n    toAddress: hexToBuf(address),\n    message: message,\n  });\n\n  const payload = privateMessage.encode();\n\n  const encObj = sigUtil.encrypt(\n    Buffer.from(publicKey).toString('base64'),\n    { data: bufToHex(payload) },\n    'x25519-xsalsa20-poly1305'\n  );\n\n  const encryptedPayload = Buffer.from(JSON.stringify(encObj), 'utf8');\n  return WakuMessage.fromBytes(encryptedPayload, PrivateMessageContentTopic);\n}\n\nfunction sendMessage(\n  waku: Waku,\n  recipientAddress: string,\n  recipientPublicKey: Uint8Array,\n  message: string,\n  callback: (res: boolean) => void\n) {\n  encodeEncryptedWakuMessage(message, recipientPublicKey, recipientAddress)\n    .then((msg) => {\n      console.log('pushing');\n      waku.lightPush\n        .push(msg)\n        .then((res) => {\n          console.log('Message sent', res);\n          callback(res ? res.isSuccess : false);\n        })\n        .catch((e) => {\n          console.error('Failed to send message', e);\n          callback(false);\n        });\n    })\n    .catch((e) => {\n      console.error('Cannot encode & encrypt message', e);\n      callback(false);\n    });\n}\n","import { Button } from '@material-ui/core';\nimport React from 'react';\n\ninterface Props {\n  setEncPublicKey: (key: Uint8Array) => void;\n  providerRequest:\n    | ((request: { method: string; params?: Array<any> }) => Promise<any>)\n    | undefined;\n  address: string | undefined;\n}\n\nexport default function GetEncryptionPublicKey({\n  setEncPublicKey,\n  providerRequest,\n  address,\n}: Props) {\n  const requestPublicKey = () => {\n    if (!providerRequest) return;\n    if (!address) return;\n\n    console.log('Getting Encryption Public Key from Wallet');\n    providerRequest({\n      method: 'eth_getEncryptionPublicKey',\n      params: [address],\n    })\n      .then((key: string | undefined) => {\n        console.log('Encryption Public key:', key);\n\n        if (typeof key !== 'string') {\n          console.error('Could not get encryption key');\n          return;\n        }\n\n        setEncPublicKey(Buffer.from(key, 'base64'));\n      })\n      .catch((error) => {\n        if (error.code === 4001) {\n          // EIP-1193 userRejectedRequest error\n          console.log(\"We can't encrypt anything without the key.\");\n        } else {\n          console.error(error);\n        }\n      });\n  };\n\n  return (\n    <Button\n      variant=\"contained\"\n      color=\"primary\"\n      onClick={requestPublicKey}\n      disabled={!providerRequest || !address}\n    >\n      Get Encryption Public Key from Wallet\n    </Button>\n  );\n}\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getNodesFromHostedJson = void 0;\n/**\n * GET list of nodes from remote HTTP host.\n *\n * Default behavior is to return nodes hosted by Status.\n *\n * @param path The property path to access the node list. The result should be\n * a string, a string array or an object. If the result is an object then the\n * values of the objects are used as multiaddresses. For example, if the GET\n * request returns `{ foo: { bar: [address1, address2] } }` then `path` should be\n * `[ \"foo\", \"bar\" ]`.\n * @param url Remote host containing bootstrap peers in JSON format.\n * @param wantedNumber The number of connections desired. Defaults to [DefaultWantedNumber].\n *\n * @returns An array of multiaddresses.\n * @throws If the remote host is unreachable or the response cannot be parsed\n * according to the passed _path_.\n */\nconst axios_1 = __importDefault(require(\"axios\"));\nconst debug_1 = __importDefault(require(\"debug\"));\nconst multiaddr_1 = require(\"multiaddr\");\nconst index_1 = require(\"./index\");\nconst dbg = debug_1.default('waku:discovery');\nconst DefaultWantedNumber = 1;\nasync function getNodesFromHostedJson(path = ['fleets', 'wakuv2.prod', 'waku-websocket'], url = 'https://fleets.status.im/', wantedNumber = DefaultWantedNumber) {\n    if (wantedNumber <= 0) {\n        return [];\n    }\n    const res = await axios_1.default.get(url, {\n        headers: { 'Content-Type': 'application/json' },\n    });\n    let nodes = res.data;\n    for (const prop of path) {\n        if (nodes[prop] === undefined) {\n            dbg(`Failed to retrieve bootstrap nodes: ${prop} does not exist on `, nodes);\n            throw `Failed to retrieve bootstrap nodes: ${prop} does not exist on ${JSON.stringify(nodes)}`;\n        }\n        nodes = nodes[prop];\n    }\n    if (Array.isArray(nodes)) {\n        return index_1.getPseudoRandomSubset(nodes, wantedNumber).map((node) => new multiaddr_1.Multiaddr(node));\n    }\n    if (typeof nodes === 'string') {\n        return [new multiaddr_1.Multiaddr(nodes)];\n    }\n    if (typeof nodes === 'object') {\n        nodes = Object.values(nodes);\n        nodes = nodes.map((node) => new multiaddr_1.Multiaddr(node));\n        return index_1.getPseudoRandomSubset(nodes, wantedNumber);\n    }\n    throw `Failed to retrieve bootstrap nodes: response format is not supported: ${JSON.stringify(nodes)}`;\n}\nexports.getNodesFromHostedJson = getNodesFromHostedJson;\n//# sourceMappingURL=hosted_json.js.map","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Bootstrap = void 0;\nconst debug_1 = __importDefault(require(\"debug\"));\nconst multiaddr_1 = require(\"multiaddr\");\nconst dns_1 = require(\"./dns\");\nconst index_1 = require(\"./index\");\nconst dbg = debug_1.default('waku:discovery:bootstrap');\n/**\n * Parse options and expose function to return bootstrap peer addresses.\n */\nclass Bootstrap {\n    constructor(opts) {\n        const maxPeers = opts.maxPeers ?? Bootstrap.DefaultMaxPeers;\n        if (opts.default) {\n            dbg('Use hosted list of peers.');\n            this.getBootstrapPeers = index_1.getNodesFromHostedJson.bind({}, undefined, undefined, maxPeers);\n        }\n        else if (opts.peers !== undefined && opts.peers.length > 0) {\n            dbg('Use provided list of peers.');\n            const allPeers = opts.peers.map((node) => new multiaddr_1.Multiaddr(node));\n            const peers = index_1.getPseudoRandomSubset(allPeers, maxPeers);\n            this.getBootstrapPeers = () => Promise.resolve(peers);\n        }\n        else if (typeof opts.getPeers === 'function') {\n            dbg('Bootstrap: Use provided getPeers function.');\n            const getPeers = opts.getPeers;\n            this.getBootstrapPeers = async () => {\n                const allPeers = await getPeers();\n                return index_1.getPseudoRandomSubset(allPeers, maxPeers).map((node) => new multiaddr_1.Multiaddr(node));\n            };\n        }\n        else if (opts.enrUrl) {\n            const enrUrl = opts.enrUrl;\n            dbg('Use provided EIP-1459 ENR Tree URL.');\n            const dns = dns_1.DnsNodeDiscovery.dnsOverHttp();\n            this.getBootstrapPeers = async () => {\n                const enrs = await dns.getPeers(maxPeers, [enrUrl]);\n                dbg(`Found ${enrs.length} peers`);\n                return enrs.map((enr) => enr.getFullMultiaddrs()).flat();\n            };\n        }\n        else {\n            dbg('No bootstrap method specified, no peer will be returned');\n            this.getBootstrapPeers = undefined;\n        }\n    }\n}\nexports.Bootstrap = Bootstrap;\nBootstrap.DefaultMaxPeers = 1;\n//# sourceMappingURL=bootstrap.js.map","import { Dispatch, SetStateAction } from 'react';\nimport { Waku, WakuMessage } from 'js-waku';\nimport { PrivateMessage, PublicKeyMessage } from './messaging/wire';\nimport { validatePublicKeyMessage } from './crypto';\nimport { Message } from './messaging/Messages';\nimport { bufToHex, equalByteArrays } from 'js-waku/lib/utils';\n\nexport const PublicKeyContentTopic =\n  '/eth-pm-wallet/1/encryption-public-key/proto';\nexport const PrivateMessageContentTopic =\n  '/eth-pm-wallet/1/private-message/proto';\n\nexport async function initWaku(): Promise<Waku> {\n  const waku = await Waku.create({ bootstrap: { default: true } });\n\n  // Wait to be connected to at least one peer\n  await new Promise((resolve, reject) => {\n    // If we are not connected to any peer within 10sec let's just reject\n    // As we are not implementing connection management in this example\n\n    setTimeout(reject, 10000);\n    waku.libp2p.connectionManager.on('peer:connect', () => {\n      resolve(null);\n    });\n  });\n\n  return waku;\n}\n\nexport function handlePublicKeyMessage(\n  myAddress: string | undefined,\n  setPublicKeys: Dispatch<SetStateAction<Map<string, Uint8Array>>>,\n  msg: WakuMessage\n) {\n  console.log('Public Key Message received:', msg);\n  if (!msg.payload) return;\n  const publicKeyMsg = PublicKeyMessage.decode(msg.payload);\n  if (!publicKeyMsg) return;\n  if (myAddress && equalByteArrays(publicKeyMsg.ethAddress, myAddress)) return;\n\n  const res = validatePublicKeyMessage(publicKeyMsg);\n  console.log('Is Public Key Message valid?', res);\n\n  if (res) {\n    setPublicKeys((prevPks: Map<string, Uint8Array>) => {\n      prevPks.set(\n        bufToHex(publicKeyMsg.ethAddress),\n        publicKeyMsg.encryptionPublicKey\n      );\n      return new Map(prevPks);\n    });\n  }\n}\n\nexport async function handlePrivateMessage(\n  setter: Dispatch<SetStateAction<Message[]>>,\n  address: string,\n  providerRequest: (request: {\n    method: string;\n    params?: Array<any>;\n  }) => Promise<any>,\n  wakuMsg: WakuMessage\n) {\n  console.log('Private Message received:', wakuMsg);\n  if (!wakuMsg.payload) return;\n\n  const decryptedPayload = await providerRequest({\n    method: 'eth_decrypt',\n    params: [wakuMsg.payloadAsUtf8, address],\n  }).catch((error) => console.log(error.message));\n\n  console.log('Decrypted Payload:', decryptedPayload);\n  const privateMessage = PrivateMessage.decode(\n    Buffer.from(decryptedPayload, 'hex')\n  );\n  if (!privateMessage) {\n    console.log('Failed to decode Private Message');\n    return;\n  }\n  if (!equalByteArrays(privateMessage.toAddress, address)) return;\n\n  const timestamp = wakuMsg.timestamp ? wakuMsg.timestamp : new Date();\n\n  console.log('Message decrypted:', privateMessage.message);\n  setter((prevMsgs: Message[]) => {\n    const copy = prevMsgs.slice();\n    copy.push({\n      text: privateMessage.message,\n      timestamp: timestamp,\n    });\n    return copy;\n  });\n}\n","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ENR = void 0;\nconst base64url_1 = __importDefault(require(\"base64url\"));\nconst bigint_buffer_1 = require(\"bigint-buffer\");\nconst multiaddr_1 = require(\"multiaddr\");\n// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n// @ts-ignore: No types available\nconst convert_1 = __importDefault(require(\"multiaddr/src/convert\"));\nconst RLP = __importStar(require(\"rlp\"));\nconst varint_1 = require(\"varint\");\nconst constants_1 = require(\"./constants\");\nconst keypair_1 = require(\"./keypair\");\nconst v4 = __importStar(require(\"./v4\"));\nclass ENR extends Map {\n    constructor(kvs = {}, seq = 1n, signature = null) {\n        super(Object.entries(kvs));\n        this.seq = seq;\n        this.signature = signature;\n    }\n    static createV4(publicKey, kvs = {}) {\n        return new ENR({\n            ...kvs,\n            id: Buffer.from('v4'),\n            secp256k1: publicKey,\n        });\n    }\n    static createFromPeerId(peerId, kvs = {}) {\n        const keypair = keypair_1.createKeypairFromPeerId(peerId);\n        switch (keypair.type) {\n            case keypair_1.KeypairType.secp256k1:\n                return ENR.createV4(keypair.publicKey, kvs);\n            default:\n                throw new Error();\n        }\n    }\n    static decodeFromValues(decoded) {\n        if (!Array.isArray(decoded)) {\n            throw new Error('Decoded ENR must be an array');\n        }\n        if (decoded.length % 2 !== 0) {\n            throw new Error('Decoded ENR must have an even number of elements');\n        }\n        const [signature, seq, ...kvs] = decoded;\n        if (!signature || Array.isArray(signature)) {\n            throw new Error('Decoded ENR invalid signature: must be a byte array');\n        }\n        if (!seq || Array.isArray(seq)) {\n            throw new Error('Decoded ENR invalid sequence number: must be a byte array');\n        }\n        const obj = {};\n        for (let i = 0; i < kvs.length; i += 2) {\n            obj[kvs[i].toString()] = Buffer.from(kvs[i + 1]);\n        }\n        const enr = new ENR(obj, bigint_buffer_1.toBigIntBE(seq), signature);\n        if (!enr.verify(RLP.encode([seq, ...kvs]), signature)) {\n            throw new Error('Unable to verify ENR signature');\n        }\n        return enr;\n    }\n    static decode(encoded) {\n        const decoded = RLP.decode(encoded);\n        return ENR.decodeFromValues(decoded);\n    }\n    static decodeTxt(encoded) {\n        if (!encoded.startsWith(this.RECORD_PREFIX)) {\n            throw new Error(`\"string encoded ENR must start with '${this.RECORD_PREFIX}'`);\n        }\n        return ENR.decode(base64url_1.default.toBuffer(encoded.slice(4)));\n    }\n    set(k, v) {\n        this.signature = null;\n        this.seq++;\n        return super.set(k, v);\n    }\n    get id() {\n        const id = this.get('id');\n        if (!id)\n            throw new Error('id not found.');\n        return id.toString('utf8');\n    }\n    get keypairType() {\n        switch (this.id) {\n            case 'v4':\n                return keypair_1.KeypairType.secp256k1;\n            default:\n                throw new Error(constants_1.ERR_INVALID_ID);\n        }\n    }\n    get publicKey() {\n        switch (this.id) {\n            case 'v4':\n                return this.get('secp256k1');\n            default:\n                throw new Error(constants_1.ERR_INVALID_ID);\n        }\n    }\n    get keypair() {\n        return keypair_1.createKeypair(this.keypairType, undefined, this.publicKey);\n    }\n    get peerId() {\n        return keypair_1.createPeerIdFromKeypair(this.keypair);\n    }\n    get nodeId() {\n        switch (this.id) {\n            case 'v4':\n                return v4.nodeId(this.publicKey);\n            default:\n                throw new Error(constants_1.ERR_INVALID_ID);\n        }\n    }\n    get ip() {\n        const raw = this.get('ip');\n        if (raw) {\n            return convert_1.default.toString(multiaddr_1.protocols.names.ip4.code, raw);\n        }\n        else {\n            return undefined;\n        }\n    }\n    set ip(ip) {\n        if (ip) {\n            this.set('ip', convert_1.default.toBytes(multiaddr_1.protocols.names.ip4.code, ip));\n        }\n        else {\n            this.delete('ip');\n        }\n    }\n    get tcp() {\n        const raw = this.get('tcp');\n        if (raw) {\n            return Number(convert_1.default.toString(multiaddr_1.protocols.names.tcp.code, raw));\n        }\n        else {\n            return undefined;\n        }\n    }\n    set tcp(port) {\n        if (port === undefined) {\n            this.delete('tcp');\n        }\n        else {\n            this.set('tcp', convert_1.default.toBytes(multiaddr_1.protocols.names.tcp.code, port));\n        }\n    }\n    get udp() {\n        const raw = this.get('udp');\n        if (raw) {\n            return Number(convert_1.default.toString(multiaddr_1.protocols.names.udp.code, raw));\n        }\n        else {\n            return undefined;\n        }\n    }\n    set udp(port) {\n        if (port === undefined) {\n            this.delete('udp');\n        }\n        else {\n            this.set('udp', convert_1.default.toBytes(multiaddr_1.protocols.names.udp.code, port));\n        }\n    }\n    get ip6() {\n        const raw = this.get('ip6');\n        if (raw) {\n            return convert_1.default.toString(multiaddr_1.protocols.names.ip6.code, raw);\n        }\n        else {\n            return undefined;\n        }\n    }\n    set ip6(ip) {\n        if (ip) {\n            this.set('ip6', convert_1.default.toBytes(multiaddr_1.protocols.names.ip6.code, ip));\n        }\n        else {\n            this.delete('ip6');\n        }\n    }\n    get tcp6() {\n        const raw = this.get('tcp6');\n        if (raw) {\n            return Number(convert_1.default.toString(multiaddr_1.protocols.names.tcp.code, raw));\n        }\n        else {\n            return undefined;\n        }\n    }\n    set tcp6(port) {\n        if (port === undefined) {\n            this.delete('tcp6');\n        }\n        else {\n            this.set('tcp6', convert_1.default.toBytes(multiaddr_1.protocols.names.tcp.code, port));\n        }\n    }\n    get udp6() {\n        const raw = this.get('udp6');\n        if (raw) {\n            return Number(convert_1.default.toString(multiaddr_1.protocols.names.udp.code, raw));\n        }\n        else {\n            return undefined;\n        }\n    }\n    set udp6(port) {\n        if (port === undefined) {\n            this.delete('udp6');\n        }\n        else {\n            this.set('udp6', convert_1.default.toBytes(multiaddr_1.protocols.names.udp.code, port));\n        }\n    }\n    /**\n     * Get the `multiaddrs` field from ENR.\n     *\n     * This field is used to store multiaddresses that cannot be stored with the current ENR pre-defined keys.\n     * These can be a multiaddresses that include encapsulation (e.g. wss) or do not use `ip4` nor `ip6` for the host\n     * address (e.g. `dns4`, `dnsaddr`, etc)..\n     *\n     * If the peer information only contains information that can be represented with the ENR pre-defined keys\n     * (ip, tcp, etc) then the usage of [[getLocationMultiaddr]] should be preferred.\n     *\n     * The multiaddresses stored in this field are expected to be location multiaddresses, ie, peer id less.\n     */\n    get multiaddrs() {\n        const raw = this.get('multiaddrs');\n        if (raw) {\n            const multiaddrs = [];\n            try {\n                let index = 0;\n                while (index < raw.length) {\n                    const sizeBytes = raw.slice(index, index + 2);\n                    const size = Buffer.from(sizeBytes).readUInt16BE(0);\n                    const multiaddrBytes = raw.slice(index + constants_1.MULTIADDR_LENGTH_SIZE, index + size + constants_1.MULTIADDR_LENGTH_SIZE);\n                    const multiaddr = new multiaddr_1.Multiaddr(multiaddrBytes);\n                    multiaddrs.push(multiaddr);\n                    index += size + constants_1.MULTIADDR_LENGTH_SIZE;\n                }\n            }\n            catch (e) {\n                throw new Error('Invalid value in multiaddrs field');\n            }\n            return multiaddrs;\n        }\n        else {\n            return undefined;\n        }\n    }\n    /**\n     * Set the `multiaddrs` field on the ENR.\n     *\n     * This field is used to store multiaddresses that cannot be stored with the current ENR pre-defined keys.\n     * These can be a multiaddresses that include encapsulation (e.g. wss) or do not use `ip4` nor `ip6` for the host\n     * address (e.g. `dns4`, `dnsaddr`, etc)..\n     *\n     * If the peer information only contains information that can be represented with the ENR pre-defined keys\n     * (ip, tcp, etc) then the usage of [[setLocationMultiaddr]] should be preferred.\n     *\n     * The multiaddresses stored in this field must to be location multiaddresses, ie, peer id less.\n     */\n    set multiaddrs(multiaddrs) {\n        if (multiaddrs === undefined) {\n            this.delete('multiaddrs');\n        }\n        else {\n            let multiaddrsBuf = Buffer.from([]);\n            multiaddrs.forEach((multiaddr) => {\n                if (multiaddr.getPeerId())\n                    throw new Error('`multiaddr` field MUST not contain peer id');\n                const bytes = multiaddr.bytes;\n                let buf = Buffer.alloc(2);\n                // Prepend the size of the next entry\n                const written = buf.writeUInt16BE(bytes.length, 0);\n                if (written !== constants_1.MULTIADDR_LENGTH_SIZE) {\n                    throw new Error(`Internal error: unsigned 16-bit integer was not written in ${constants_1.MULTIADDR_LENGTH_SIZE} bytes`);\n                }\n                buf = Buffer.concat([buf, bytes]);\n                multiaddrsBuf = Buffer.concat([multiaddrsBuf, buf]);\n            });\n            this.set('multiaddrs', multiaddrsBuf);\n        }\n    }\n    getLocationMultiaddr(protocol) {\n        if (protocol === 'udp') {\n            return (this.getLocationMultiaddr('udp4') || this.getLocationMultiaddr('udp6'));\n        }\n        if (protocol === 'tcp') {\n            return (this.getLocationMultiaddr('tcp4') || this.getLocationMultiaddr('tcp6'));\n        }\n        const isIpv6 = protocol.endsWith('6');\n        const ipVal = this.get(isIpv6 ? 'ip6' : 'ip');\n        if (!ipVal) {\n            return undefined;\n        }\n        const isUdp = protocol.startsWith('udp');\n        const isTcp = protocol.startsWith('tcp');\n        let protoName, protoVal;\n        if (isUdp) {\n            protoName = 'udp';\n            protoVal = isIpv6 ? this.get('udp6') : this.get('udp');\n        }\n        else if (isTcp) {\n            protoName = 'tcp';\n            protoVal = isIpv6 ? this.get('tcp6') : this.get('tcp');\n        }\n        else {\n            return undefined;\n        }\n        if (!protoVal) {\n            return undefined;\n        }\n        // Create raw multiaddr buffer\n        // multiaddr length is:\n        //  1 byte for the ip protocol (ip4 or ip6)\n        //  N bytes for the ip address\n        //  1 or 2 bytes for the protocol as buffer (tcp or udp)\n        //  2 bytes for the port\n        const ipMa = multiaddr_1.protocols.names[isIpv6 ? 'ip6' : 'ip4'];\n        const ipByteLen = ipMa.size / 8;\n        const protoMa = multiaddr_1.protocols.names[protoName];\n        const protoBuf = varint_1.encode(protoMa.code);\n        const maBuf = new Uint8Array(3 + ipByteLen + protoBuf.length);\n        maBuf[0] = ipMa.code;\n        maBuf.set(ipVal, 1);\n        maBuf.set(protoBuf, 1 + ipByteLen);\n        maBuf.set(protoVal, 1 + ipByteLen + protoBuf.length);\n        return new multiaddr_1.Multiaddr(maBuf);\n    }\n    setLocationMultiaddr(multiaddr) {\n        const protoNames = multiaddr.protoNames();\n        if (protoNames.length !== 2 &&\n            protoNames[1] !== 'udp' &&\n            protoNames[1] !== 'tcp') {\n            throw new Error('Invalid multiaddr');\n        }\n        const tuples = multiaddr.tuples();\n        if (!tuples[0][1] || !tuples[1][1]) {\n            throw new Error('Invalid multiaddr');\n        }\n        // IPv4\n        if (tuples[0][0] === 4) {\n            this.set('ip', tuples[0][1]);\n            this.set(protoNames[1], tuples[1][1]);\n        }\n        else {\n            this.set('ip6', tuples[0][1]);\n            this.set(protoNames[1] + '6', tuples[1][1]);\n        }\n    }\n    /**\n     * Returns the full multiaddr from the ENR fields matching the provided\n     * `protocol` parameter.\n     * To return full multiaddrs from the `multiaddrs` ENR field,\n     * use [[ENR.getFullMultiaddrs]]\n     *\n     * @param protocol\n     */\n    getFullMultiaddr(protocol) {\n        const locationMultiaddr = this.getLocationMultiaddr(protocol);\n        if (locationMultiaddr) {\n            return locationMultiaddr.encapsulate(`/p2p/${this.peerId.toB58String()}`);\n        }\n        return;\n    }\n    /**\n     * Returns the full multiaddrs from the `multiaddrs` ENR field.\n     */\n    getFullMultiaddrs() {\n        if (this.multiaddrs) {\n            return this.multiaddrs.map((ma) => {\n                return ma.encapsulate(`/p2p/${this.peerId.toB58String()}`);\n            });\n        }\n        return [];\n    }\n    verify(data, signature) {\n        if (!this.get('id') || this.id !== 'v4') {\n            throw new Error(constants_1.ERR_INVALID_ID);\n        }\n        if (!this.publicKey) {\n            throw new Error('Failed to verify ENR: No public key');\n        }\n        return v4.verify(this.publicKey, data, signature);\n    }\n    sign(data, privateKey) {\n        switch (this.id) {\n            case 'v4':\n                this.signature = v4.sign(privateKey, data);\n                break;\n            default:\n                throw new Error(constants_1.ERR_INVALID_ID);\n        }\n        return this.signature;\n    }\n    encodeToValues(privateKey) {\n        // sort keys and flatten into [k, v, k, v, ...]\n        const content = Array.from(this.keys())\n            .sort((a, b) => a.localeCompare(b))\n            .map((k) => [k, this.get(k)])\n            .flat();\n        content.unshift(Number(this.seq));\n        if (privateKey) {\n            content.unshift(this.sign(RLP.encode(content), privateKey));\n        }\n        else {\n            if (!this.signature) {\n                throw new Error(constants_1.ERR_NO_SIGNATURE);\n            }\n            content.unshift(this.signature);\n        }\n        return content;\n    }\n    encode(privateKey) {\n        const encoded = RLP.encode(this.encodeToValues(privateKey));\n        if (encoded.length >= constants_1.MAX_RECORD_SIZE) {\n            throw new Error('ENR must be less than 300 bytes');\n        }\n        return encoded;\n    }\n    encodeTxt(privateKey) {\n        return ENR.RECORD_PREFIX + base64url_1.default.encode(this.encode(privateKey));\n    }\n}\nexports.ENR = ENR;\nENR.RECORD_PREFIX = 'enr:';\n//# sourceMappingURL=enr.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ERR_INVALID_KEYPAIR_TYPE = exports.ERR_TYPE_NOT_IMPLEMENTED = void 0;\nexports.ERR_TYPE_NOT_IMPLEMENTED = 'Keypair type not implemented';\nexports.ERR_INVALID_KEYPAIR_TYPE = 'Invalid keypair type';\n//# sourceMappingURL=constants.js.map"],"sourceRoot":""}